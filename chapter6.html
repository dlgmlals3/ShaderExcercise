<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKSL 셰이더 교육 자료</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <h1> SKSL 셰이더 교육 자료</h1>
        <p> Chapter 6. 블러 알고리즘 만들어보기 </p>

        <nav class="chapter-nav">
            <a href="index.html" class="chapter-btn"> 0. 기본 함수 설명 </a>
            <a href="chapter1.html" class="chapter-btn">1. 기본 도형과 패턴
            <a href="chapter2.html" class="chapter-btn">2. 기본 도형 회전 이동 확대
            <a href="chapter3.html" class="chapter-btn">3. 랜덤 함수와 노이즈 함수 </a><br>
            <a href="chapter4.html" class="chapter-btn">4. Fractal </a>
            <a href="chapter5.html" class="chapter-btn">5. 이미지 필터링 및 컬러 커브 </a>
            <a href="chapter6.html" class="chapter-btn active">6. 블러 알고리즘 </a>
            <a href="chapter7.html" class="chapter-btn">7. 멀티 패스 </a>
        </nav>
    </div>

    <div class="container">
        <div class="lesson">
            <div class="lesson-header">
                <div class="lesson-title"> 이미지 샘플링 해보기 </div>
                <div class="lesson-description">
                    <h3> 학습 목표</h3>
                    가우시안 블러 알고리즘 만들어보기<br>
                </div>
            </div>

            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts1')">
                    <h4> 그래프 그려보기  ( 라이브러리 포함 ) </h4><br>                                        
                    <span class="toggle-icon" id="icon-concepts1">▼</span>
                </div>
                <div class="concepts-content" id="concepts1">
                    <ul>                                                   
                        <li><strong> 랜덤 함수 </strong><br>
                            <div class="code-example">                     
    <code>float sigma = 0.2;   
float y = exp(-(p.x*p.x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma);</code>
                            </div>
                    </ul>
                </div>
            </div>

            <div class="lesson-content">
                <div class="editor-section">
                    <div class="section-header">SKSL 실습 코드</div>
                    <textarea class="code-editor" id="editor1">
float y = p.x;           
                    </textarea>
                    <div class="controls">
                        <button class="btn" onclick="compileShader(1)"> 실행</button>                     
                    </div>
                </div>
                
                <div class="preview-section">
                    <div class="section-header">미리보기</div>
                    <div id="error1"></div>
                    <div class="preview-container">
                        <div class="loading" id="loading1">CanvasKit 로딩 중...</div>
                        <canvas class="preview-canvas" id="canvas1" width="300" height="300" style="display: none;"></canvas>
                    </div>
                </div>
            </div>

            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts8')">
                    <h4> 가우시안 블러 알고리즘 </h4><br>            
                    <span class="toggle-icon" id="icon-concepts8">▼</span>
                </div>        
                <div class="concepts-content" id="concepts8">        
                    <ul><br>
                    가우시안 블러는 가우시안 필터를 사용한 블러 알고리즘 입니다.<br><br>
                    <img src="materials/chapter6/gausian2.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    기본적인 평균 필터의 경우, 대상 점 주변의 픽셀 값을 모두 동일한 가중치로 평균내어 블러 효과를 만듭니다.<br>
                    하지만 이러한 특성은 대상 점과 가까운 픽셀이 먼 픽셀보다 더 연관이 있다는 사실을 반영하지 못합니다.<br>
                    가까운 픽셀에 더 많은 가중치를 줄 필요가 있습니다.<br>
                    아래 보이는 표는 가우시안 커널 5x5의 예시 입니다.<br><br>
                    <img src="materials/chapter6/gausian1.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>

                    <h3>파라메터인 가우시안 함수 x(dist), Sigma, radius 대해서 알아 봅니다</h3><br>
                    x는 소스 픽셀과 대상 픽셀과의 거리입니다.<br>
                    블러의 Radius는 블러의 범위를 결정합니다. Radius가 클수록 더 넓은 영역의 픽셀을 고려하여 블러 효과를 만듭니다.<br>
                    블러의 Radius는 커널 사이즈를 결정하며, Radius * 2 + 1 이 커널 크기가 됩니다<br>
                    예를 들어 3이면 7x7 커널이 됩니다.<br>
                    Sigma는 가우시안 함수의 표준 편차를 나타내며, 블러의 강도를 조절합니다. <br>                    
                    Sigma가 클수록 블러 효과가 더 부드럽고 넓게 퍼집니다.<br>
                    그래서 radius와 sigma는 비례 관계에 있습니다. <br>
                    sigma 값이 2만 넘어도 그래프가 평탄해 집니다.<br>
                    실제 블러 코드에서는 radius 값이 크게 되어도, 커널 사이즈와, 시그마 값은 고정이고 다운샘플 방식으로 처리가 됩니다.<br><br>
                    <img src="materials/chapter6/gausian3.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    Assignment <br>
                    1. 위에서 가우시안 그래프를 그려 봅니다.<br>
                    2. Blur Radius가 20이면 샘플링 개수는 ?? <br><br>
                    <li><h3><strong> 가우시안 블러 알고리즘 코드 </strong></h3><br>
                    <div class="code-example">                     
<code>uniform float2 iResolution;
uniform shader iTexture;
uniform float  blurRadius;

float gaussian(float x, float sigma) {
    return exp(-(x*x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma);
}

half4 main(float2 fragCoord) {
    const int MAX_RADIUS = 20;
    float r = clamp(blurRadius, 0.0, float(MAX_RADIUS));
    float sigma = max(r, 1.0) * 0.33;

    half4 color = half4(0.0);
    float totalWeight = 0.0;

    for (int x = -MAX_RADIUS; x <= MAX_RADIUS; ++x) {
        for (int y = -MAX_RADIUS; y <= MAX_RADIUS; ++y) {
            float2 off = float2(float(x), float(y));
            float dist = length(off);
            if (dist > r) continue;

            float w = gaussian(dist, sigma);
            color += iTexture.eval(fragCoord + off) * w;
            totalWeight += w;
        }
    }
    return color / max(totalWeight, 1e-6);
}</code>
                            </div>
                        </li>                        
                    </ul>                  
                </div>
            </div>
            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts3')">
                    <h4> 투 패스 가우시안 블러 알고리즘 </h4><br>            
                    <span class="toggle-icon" id="icon-concepts3">▼</span>
                </div>        
                <div class="concepts-content" id="concepts3">        
                    <ul><br>
                    투 패스 가우시안 블러는 가우시안 필터 성능 개선하기 위한 기법입니다.<br>
                    가우시안 블러는 각 픽셀에 대해 가우시안 커널을 사용하기 때문에 가우시안 커널 크기가 커지게 되면 많은 샘플링을 수행 합니다. <br>
                    가우시안 블러를 두 번에 나누어서 적용하는 방식입니다.<br>
                    가로로 픽셀의 대해서만 가우시안 블러를 적용한 후, 해당 결과를 세로로 픽셀에 대해서만 가우시안 블러를 적용합니다.<br>
                    // TODO two pass 가우시안 알고리즘 link 
                    Blur Radius가 20이면 샘플링 개수는 ??<br><br>
                    <img src="materials/chapter6/gausian4.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    <div class="code-example">                     
<code>uniform float2 iResolution;
uniform shader iTexture;
uniform float  blurRadius;

float gaussian(float x, float sigma) {
    return exp(-(x*x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * 3.14159265) * sigma);
}

half4 horizontalBlur(float2 fragCoord, float sigma, int radius) {
    half4 color = half4(0.0);
    float totalWeight = 0.0;
    const int MAX_RADIUS = 20;
    float r = clamp(blurRadius, 0.0, float(MAX_RADIUS));
    
    for (int x = -MAX_RADIUS; x <= MAX_RADIUS; ++x) {
        float2 off = float2(float(x), 0.0);
        float dist = abs(float(x));
        if (dist > r) continue;

        float w = gaussian(dist, sigma);
        color += iTexture.eval(fragCoord + off) * w;
        totalWeight += w;
    }
    return color / max(totalWeight, 1e-6);
}

half4 verticalBlur(float2 fragCoord, float sigma, int radius) {
    half4 color = half4(0.0);
    float totalWeight = 0.0;
    const int MAX_RADIUS = 20;
    float r = clamp(blurRadius, 0.0, float(MAX_RADIUS));

    for (int y = -MAX_RADIUS; y <= MAX_RADIUS; ++y) {
        float2 off = float2(0.0, float(y));
        float dist = abs(float(y));
        if (dist > r) continue;

        float w = gaussian(dist, sigma);
        color += iTexture.eval(fragCoord + off) * w;
        totalWeight += w;
    }
    return color / max(totalWeight, 1e-6);
}

half4 main(float2 fragCoord) {
    const int MAX_RADIUS = 20;
    float r = clamp(blurRadius, 0.0, float(MAX_RADIUS));
    float sigma = max(r, 1.0) * 0.33;

    half4 color = half4(0.0);
    float totalWeight = 0.0;
    // two pass 알고리즘 아님..각 파이프라인의 결과만 보기 위함.
    //color = horizontalBlur(fragCoord, sigma, int(r));
    //color = verticalBlur(fragCoord, sigma, int(r));

    return color;
}
</code>
                            </div>
                        </li>                        
                    </ul>                  
                </div>
            </div>
            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts4')">
                    <h4> Down Scale, Up Scale </h4><br>            
                    <span class="toggle-icon" id="icon-concepts4">▼</span>
                </div>        
                <div class="concepts-content" id="concepts4">        
                    <ul><br>
                    blur radius가 작은 경우는 큰 문제가 없지만, <br>
                    blur radius가 커지면 커널 사이즈와 시그마 값이 커져서 샘플링 개수가 많아져서 성능이 떨어 집니다.<br>
                    이를 해결하기 위한 방법이 다운샘플링과 업샘플링 입니다.<br>
                    이미지를 다운 스케일을 하여 이미지 해상도를 낮춘 뒤, 낮은 시그마 값과 커널 사이즈로 블러를 적용한 후, <br>
                    다시 업 스케일을 하여 원래 해상도로 복원하는 방법입니다.<br><br>
                    <h3>Down Scale</h3> <br>
                    <img src="materials/chapter6/downscale.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    <div class="code-example">                     
<code>uniform shader iTexture;
uniform float2 iResolution;

half4 main(float2 fragCoord) {
    float  scale = 4.;           // 다운스케일 배율 (2.0 = 1/2, 4.0 = 1/4)
    float2 srcCoordCenter = (fragCoord + 0.5) * scale;
    
    // 2x2 박스 필터 (안티앨리어싱)
    half4 c00 = iTexture.eval(srcCoordCenter + float2(-0.5 * scale, -0.5 * scale));
    half4 c10 = iTexture.eval(srcCoordCenter + float2( 0.5 * scale, -0.5 * scale));
    half4 c01 = iTexture.eval(srcCoordCenter + float2(-0.5 * scale,  0.5 * scale));
    half4 c11 = iTexture.eval(srcCoordCenter + float2( 0.5 * scale,  0.5 * scale));
    
    // 4개 샘플의 평균
    return (c00 + c10 + c01 + c11) * 0.25;
}</code>
                        </div>                
                    </ul>
                    <ul><br>
                    UP Scale <br>                    
                    <img src="materials/chapter6/upscale.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    <div class="code-example">                     
<code>uniform shader iTexture;
uniform float2 iResolution;
uniform float blurRadius;

half4 main(float2 fragCoord) {
    float scale = 4.0;
    
    // 다운스케일된 텍스처 좌표
    float2 downscaledCoord = fragCoord / scale;
    
    // 바이리니어 보간을 위한 4개 샘플
    float2 baseCoord = floor(downscaledCoord);
    float2 frac = fract(downscaledCoord);
    
    half4 c00 = iTexture.eval(baseCoord + float2(0.0, 0.0));
    half4 c10 = iTexture.eval(baseCoord + float2(1.0, 0.0));
    half4 c01 = iTexture.eval(baseCoord + float2(0.0, 1.0));
    half4 c11 = iTexture.eval(baseCoord + float2(1.0, 1.0));
    
    // 바이리니어 보간
    half4 c0 = mix(c00, c10, frac.x);
    half4 c1 = mix(c01, c11, frac.x);
    return mix(c0, c1, frac.y);
}</code>
                        </div>                
                    </ul>                      
                </div>
            </div>
            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts2')">
                    <h4> Gawase Blur </h4><br>            
                    <span class="toggle-icon" id="icon-concepts2">▼</span>
                </div>        
                <div class="concepts-content" id="concepts2">        
                    <ul><br>                    
                    가와세 블러는 소수 탭을 여러 패스로 누적하여 큰 반경의 블러를 효율적으로 구현하는 기법입니다.<br>
                    가우시안 블러보다 퀄리티는 좋지 않지만, 성능은 좋습니다.<br><br>
                    탭이란 샘플링하는 포인트를 의미하는데, 아래 예제는 9탭을 사용합니다. <br>
                    가우시안 블러와 언뜻 비슷해보이지만, 가우시안 블러는 radius가 커지게 되면 커널 사이즈가 커지는 반면,<br>
                    가와세 블러는 radius가 커지더라도 커널 사이즈는 고정이며, step(offset) 값이 변하게 됩니다.<br><br>
                    blur radius가 커지면 step이 커지게 되고, 멀리 떨어진 픽셀을 샘플링하게 됩니다.<br>
                    퀄리티 문제로 인하여 다운샘플링과 함께 패스를 여러번 적용 합니다.<br>
                    아래는 1패스 9탭 가와세 블러 코드 입니다.<br>
                    <div class="code-example">                     
<code>uniform float2 iResolution;
uniform shader iTexture;
uniform float  blurRadius;

half4 main(float2 fragCoord) {
    float r = clamp(blurRadius, 0.0, 20.0);
    
    half4 sum = half4(0.0);
    
    // 중심
    sum += iTexture.eval(fragCoord) * 4.0;
    
    // 상하좌우
    sum += iTexture.eval(fragCoord + float2( 0, -r)) * 2.0;
    sum += iTexture.eval(fragCoord + float2(-r,  0)) * 2.0;
    sum += iTexture.eval(fragCoord + float2( r,  0)) * 2.0;
    sum += iTexture.eval(fragCoord + float2( 0,  r)) * 2.0;
    
    // 대각선
    sum += iTexture.eval(fragCoord + float2(-r, -r));
    sum += iTexture.eval(fragCoord + float2( r, -r));
    sum += iTexture.eval(fragCoord + float2(-r,  r));
    sum += iTexture.eval(fragCoord + float2( r,  r));
    
    return sum / 16.0;
}  
</code>
                            </div>
                        </li>                        
                    </ul>                  
                </div>
            </div>
            <div class="lesson-content">
                <div class="editor-section">
                    <div class="section-header">SKSL 코드</div>
                    <textarea class="code-editor" id="editor3">
uniform float2 iResolution;
uniform shader iTexture;
uniform float  blurRadius;

half4 main(float2 fragCoord) {
    return half4(0., 0., 1., 1.);
}
</textarea>
                    <div class="controls">
                        <button class="btn" onclick="compileShader(3)">실행</button>
                    </div>
                    <div style="padding: 10px; background-color: #494949; border-radius: 1px;">
                        <label for="radiusSlider3" style="display: inline-block; width: 100px;">Blur Radius:</label>
                        <input type="range" id="radiusSlider3" min="0" max="20" value="5" step="0.5" 
                            style="width: 150px; vertical-align: middle;"
                            oninput="updateRadius(3, this.value)">
                        <span id="radiusValue3" style="display: inline-block; width: 40px; margin-left: 10px;">5.0</span>
                    </div>
                </div>

                <div class="preview-section">
                    <div class="section-header">미리보기</div>
                    <div id="error3"></div>
                    <div class="preview-container">
                        <div class="loading" id="loading3">CanvasKit 로딩 중...</div>
                        <canvas class="preview-canvas" id="canvas3" width="300" height="300" style="display: none;"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function updateRadius(lessonNum, value) {
            document.getElementById(`radiusValue${lessonNum}`).textContent = parseFloat(value).toFixed(1);
            if (window.setUniformValue) {
                window.setUniformValue(lessonNum, 'blurRadius', parseFloat(value));
            }
        }

        function toggleConcepts(conceptsId) {
            const content = document.getElementById(conceptsId);
            const icon = document.getElementById(`icon-${conceptsId}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                icon.textContent = '▲';
                icon.style.transform = 'rotate(180deg)';
            } else {
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                icon.textContent = '▼';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function toggleCode(codeId) {
            const content = document.getElementById(codeId);
            const toggle = document.getElementById(`toggle-${codeId}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = '400px';
                toggle.textContent = '접기';
            } else {
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                toggle.textContent = '펼치기';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const sectionsToClose = ['concepts1', 'concepts2', 'concepts3', 'concepts4', 'concepts5', 'concepts6', 'concepts7', 'concepts8'];
            
            sectionsToClose.forEach(conceptsId => {
                const content = document.getElementById(conceptsId);
                const icon = document.getElementById(`icon-${conceptsId}`);
                const header = document.querySelector(`[onclick="toggleConcepts('${conceptsId}')"]`);
                
                if (content) {
                    content.classList.add('collapsed');
                    content.style.maxHeight = '0';
                }
                if (icon) {
                    icon.textContent = '▼';
                }
                if (header) {
                    header.classList.add('closed');
                }
            });
        });

        function compileShader(id) {
            console.log(`Compiling shader ${id}...`);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvaskit-wasm/0.38.0/canvaskit.min.js"></script>
    <script src="shader-tutorial.js"></script>
</body>
</html>