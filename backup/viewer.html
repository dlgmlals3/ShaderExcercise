<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGL Shadow Mapping with GLTF/GLB Texture Support</title>
  <style>
    @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
    body { margin: 0; }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .gman-widget-value { min-width: 5em; }

    /* ★ 설정창 우측 */
    #uiContainer {
      position: fixed;
      right: 12px;
      top: 12px;
      left: auto;
      z-index: 9999;
      pointer-events: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 12px;
      color: white;
      min-width: 360px;
      max-width: 420px;
    }

    #gltfControls {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.15);
      background: rgba(42,42,42,0.35);
      border-radius: 6px;
      padding: 10px;
    }
    #gltfControls label { color: white; margin-right: 10px; }
    #modelStatus { color: #bbb; margin-left: 10px; }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <!-- ★ webgl-lessons-ui.js가 #ui에 appendChild 하므로 반드시 존재해야 함 -->
  <div id="uiContainer">
    <div id="ui"></div>
    <div id="gltfControls">
      <label>GLTF/GLB:</label>
      <input type="file" id="gltfFile" accept=".gltf,.glb" />
      <span id="modelStatus">대기 중...</span>
    </div>
  </div>

  <!-- vertex shader -->
  <script id="vertex-shader-3d" type="x-shader/x-vertex">
    attribute vec4 a_position;
    attribute vec2 a_texcoord;
    attribute vec3 a_normal;

    uniform mat4 u_projection;
    uniform mat4 u_view;
    uniform mat4 u_world;
    uniform mat4 u_textureMatrix;

    varying vec2 v_texcoord;
    varying vec4 v_projectedTexcoord;
    varying vec3 v_normal;

    void main() {
      vec4 worldPosition = u_world * a_position;
      gl_Position = u_projection * u_view * worldPosition;
      v_texcoord = a_texcoord;
      v_normal = mat3(u_world) * a_normal;
      v_projectedTexcoord = u_textureMatrix * worldPosition;
    }
  </script>

  <!-- fragment shader -->
  <script id="fragment-shader-3d" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 v_texcoord;
    varying vec4 v_projectedTexcoord;
    varying vec3 v_normal;

    uniform vec4 u_colorMult;
    uniform sampler2D u_texture;
    uniform sampler2D u_projectedTexture;
    uniform float u_bias;
    uniform vec3 u_reverseLightDirection;

    float hardShadow(vec3 projectedTexcoord, float currentDepth) {
      float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
      return (projectedDepth <= currentDepth) ? 0.0 : 1.0;
    }

    void main() {
      vec3 normal = normalize(v_normal);
      float light = dot(normal, u_reverseLightDirection);

      vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
      float currentDepth = projectedTexcoord.z - u_bias;

      bool inRange =
        projectedTexcoord.x >= 0.0 &&
        projectedTexcoord.x <= 1.0 &&
        projectedTexcoord.y >= 0.0 &&
        projectedTexcoord.y <= 1.0;

      float shadowLight = inRange ? hardShadow(projectedTexcoord, currentDepth) : 1.0;

      vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
      gl_FragColor = vec4(texColor.rgb * light * shadowLight, texColor.a);
    }
  </script>

  <!-- vertex shader - depth -->
  <script id="color-vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position;

    uniform mat4 u_projection;
    uniform mat4 u_view;
    uniform mat4 u_world;

    void main() {
      gl_Position = u_projection * u_view * u_world * a_position;
    }
  </script>

  <!-- fragment shader - depth -->
  <script id="color-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
      gl_FragColor = u_color;
    }
  </script>

  <!-- External libraries -->
  <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
  <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
  <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
  <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>

  <script>
    'use strict';

    function main() {
      console.log('main Start..');

      const canvas = document.querySelector('#canvas');
      const gl = canvas.getContext('webgl');
      if (!gl) return;

      const ext = gl.getExtension('WEBGL_depth_texture');
      if (!ext) return alert('need WEBGL_depth_texture');

      // Setup GLSL programs
      const textureProgramInfo = webglUtils.createProgramInfo(gl, ['vertex-shader-3d', 'fragment-shader-3d']);
      const colorProgramInfo   = webglUtils.createProgramInfo(gl, ['color-vertex-shader', 'color-fragment-shader']);

      // Create geometries
      const sphereBufferInfo = primitives.createSphereBufferInfo(gl, 1, 32, 24);
      const planeBufferInfo  = primitives.createPlaneBufferInfo(gl, 20, 20, 1, 1);
      const cubeBufferInfo   = primitives.createCubeBufferInfo(gl, 2);

      const cubeLinesBufferInfo = webglUtils.createBufferInfoFromArrays(gl, {
        position: [
          -1, -1, -1,  1, -1, -1, -1,  1, -1,  1,  1, -1,
          -1, -1,  1,  1, -1,  1, -1,  1,  1,  1,  1,  1,
        ],
        indices: [
          0, 1, 1, 3, 3, 2, 2, 0,
          4, 5, 5, 7, 7, 6, 6, 4,
          0, 4, 1, 5, 3, 7, 2, 6,
        ],
      });

      // Checkerboard texture (fallback)
      const checkerboardTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, 8, 8, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE,
        new Uint8Array([
          0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
          0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
          0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
          0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
          0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
          0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
          0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
          0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        ])
      );
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      // 1x1 white texture (fallback when no baseColorTexture)
      function create1x1TextureRGBA(gl, r, g, b, a) {
        const t = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, t);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                      new Uint8Array([r, g, b, a]));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return t;
      }
      const whiteTexture = create1x1TextureRGBA(gl, 255, 255, 255, 255);

      // Depth texture
      const depthTextureSize = 512;
      const depthTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, depthTextureSize, depthTextureSize, 0,
        gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // Depth framebuffer
      const depthFramebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);

      function degToRad(d) { return d * Math.PI / 180; }

      const settings = {
        cameraX: 6,
        cameraY: 12,
        posX: 2.5,
        posY: 4.8,
        posZ: 7,
        targetX: 3.5,
        targetY: 0,
        targetZ: 3.5,
        projWidth: 10,
        projHeight: 10,
        perspective: false,
        fieldOfView: 120,
        bias: 0.04,
      };

      // UI setup (requires #ui)
      webglLessonsUI.setupUI(document.querySelector('#ui'), settings, [
        { type: 'slider', key: 'cameraX', min: -10, max: 10, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'cameraY', min: 1, max: 20, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'posX', min: -10, max: 10, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'posY', min: 1, max: 20, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'posZ', min: 1, max: 20, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'targetX', min: -10, max: 10, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'targetY', min: 0, max: 20, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'targetZ', min: -10, max: 20, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'projWidth', min: 0, max: 100, change: render, precision: 2, step: 0.001 },
        { type: 'slider', key: 'projHeight', min: 0, max: 100, change: render, precision: 2, step: 0.001 },
        { type: 'checkbox', key: 'perspective', change: render },
        { type: 'slider', key: 'fieldOfView', min: 1, max: 179, change: render },
        { type: 'slider', key: 'bias', min: 0.0, max: 0.1, change: render, precision: 4, step: 0.001 },
      ]);

      const fieldOfViewRadians = degToRad(60);

      const planeUniforms = {
        u_colorMult: [0.5, 0.5, 1, 1],
        u_color: [1, 0, 0, 1],
        u_texture: checkerboardTexture,
        u_world: m4.translation(0, 0, 0),
      };
      const sphereUniforms = {
        u_colorMult: [1, 0.5, 0.5, 1],
        u_color: [0, 0, 1, 1],
        u_texture: checkerboardTexture,
        u_world: m4.translation(2, 3, 4),
      };
      const cubeUniforms = {
        u_colorMult: [0.5, 1, 0.5, 1],
        u_color: [0, 0, 1, 1],
        u_texture: checkerboardTexture,
        u_world: m4.translation(3, 1, 0),
      };

      // =========================
      // GLTF/GLB loader utilities
      // =========================
      function componentTypeToArrayCtor(componentType) {
        switch (componentType) {
          case 5120: return Int8Array;
          case 5121: return Uint8Array;
          case 5122: return Int16Array;
          case 5123: return Uint16Array;
          case 5125: return Uint32Array;
          case 5126: return Float32Array;
          default: throw new Error('Unknown componentType: ' + componentType);
        }
      }

      function typeToNumComponents(type) {
        switch (type) {
          case 'SCALAR': return 1;
          case 'VEC2':   return 2;
          case 'VEC3':   return 3;
          case 'VEC4':   return 4;
          case 'MAT2':   return 4;
          case 'MAT3':   return 9;
          case 'MAT4':   return 16;
          default: throw new Error('Unknown accessor type: ' + type);
        }
      }

      function getAccessorArray(gltf, buffers, accessorIndex) {
        const acc = gltf.accessors[accessorIndex];
        const bv  = gltf.bufferViews[acc.bufferView];

        const bufferIndex = bv.buffer || 0;
        const rawBuffer = buffers[bufferIndex];
        if (!rawBuffer) {
          throw new Error('Missing buffer data. (외부 .bin을 참조하는 .gltf는 현재 구조에서 자동 로드 불가. GLB 추천)');
        }

        const Ctor = componentTypeToArrayCtor(acc.componentType);
        const numComp = typeToNumComponents(acc.type);
        const byteOffset = (bv.byteOffset || 0) + (acc.byteOffset || 0);

        if (bv.byteStride && bv.byteStride !== numComp * Ctor.BYTES_PER_ELEMENT) {
          throw new Error('Interleaved bufferView(byteStride) not supported in this simple loader.');
        }

        return new Ctor(rawBuffer, byteOffset, acc.count * numComp);
      }

      async function loadGLTF(file) {
        const reader = new FileReader();
        return new Promise((resolve, reject) => {
          reader.onload = (e) => {
            try {
              const arrayBuffer = e.target.result;
              let gltfData = null;
              let buffers = [];

              const magic = new Uint32Array(arrayBuffer, 0, 1)[0];

              if (magic === 0x46546C67) {
                // GLB
                const view = new DataView(arrayBuffer);
                const length = view.getUint32(8, true);
                let offset = 12;

                while (offset < length) {
                  const chunkLength = view.getUint32(offset, true);
                  const chunkType = view.getUint32(offset + 4, true);

                  if (chunkType === 0x4E4F534A) { // JSON
                    const jsonData = new Uint8Array(arrayBuffer, offset + 8, chunkLength);
                    const jsonString = new TextDecoder().decode(jsonData);
                    gltfData = JSON.parse(jsonString);
                  } else if (chunkType === 0x004E4942) { // BIN
                    const binChunk = arrayBuffer.slice(offset + 8, offset + 8 + chunkLength);
                    buffers.push(binChunk);
                  }
                  offset += 8 + chunkLength;
                }
              } else {
                // GLTF JSON only (외부 리소스 로드 없음)
                const jsonString = new TextDecoder().decode(arrayBuffer);
                gltfData = JSON.parse(jsonString);
                buffers = [];
              }

              resolve({ gltf: gltfData, buffers });
            } catch (err) {
              reject(err);
            }
          };
          reader.onerror = reject;
          reader.readAsArrayBuffer(file);
        });
      }

      function createGLTextureFromImage(gl, img) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        return tex;
      }

      async function loadGLBImageFromBufferView(gltf, buffers, imageIndex) {
        const img = gltf.images[imageIndex];
        if (!img || img.bufferView === undefined) return null;

        const bv = gltf.bufferViews[img.bufferView];
        const buf = buffers[bv.buffer || 0];
        if (!buf) return null;

        const byteOffset = bv.byteOffset || 0;
        const byteLength = bv.byteLength;
        const bytes = new Uint8Array(buf, byteOffset, byteLength);
        const mimeType = img.mimeType || "image/png";
        const blob = new Blob([bytes], { type: mimeType });

        if ('createImageBitmap' in window) {
          return await createImageBitmap(blob);
        } else {
          return await new Promise((resolve, reject) => {
            const url = URL.createObjectURL(blob);
            const im = new Image();
            im.onload = () => { URL.revokeObjectURL(url); resolve(im); };
            im.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
            im.src = url;
          });
        }
      }

      async function buildGLTFTextures(gl, gltf, buffers) {
        const gltfTextures = [];
        if (!gltf.textures || !gltf.images) return gltfTextures;

        const imageTexCache = new Map();

        for (let ti = 0; ti < gltf.textures.length; ti++) {
          const t = gltf.textures[ti];
          const srcIndex = t.source;
          if (srcIndex === undefined) { gltfTextures[ti] = null; continue; }

          if (!imageTexCache.has(srcIndex)) {
            const imgObj = await loadGLBImageFromBufferView(gltf, buffers, srcIndex);
            imageTexCache.set(srcIndex, imgObj ? createGLTextureFromImage(gl, imgObj) : null);
          }
          gltfTextures[ti] = imageTexCache.get(srcIndex);
        }
        return gltfTextures;
      }

      // =========================
      // GLTF parsed primitives
      // =========================
      let gltfPrims = null; // [{ bufferInfo, texture }]
      let modelScale = 1.0;
      let modelOffset = [0, 0, 0];

      async function parseGLTF(gltfData, buffers) {
        const prims = [];

        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        if (!gltfData.meshes || !gltfData.accessors || !gltfData.bufferViews) {
          throw new Error('Invalid glTF: missing meshes/accessors/bufferViews');
        }

        const gltfTextures = await buildGLTFTextures(gl, gltfData, buffers);

        function getBaseColorTexForPrimitive(primitive) {
          const matIndex = primitive.material;
          if (matIndex === undefined || !gltfData.materials) return null;

          const mat = gltfData.materials[matIndex];
          const pbr = mat && mat.pbrMetallicRoughness;
          if (!pbr || !pbr.baseColorTexture) return null;

          const texIndex = pbr.baseColorTexture.index;
          return gltfTextures[texIndex] || null;
        }

        gltfData.meshes.forEach((mesh) => {
          mesh.primitives.forEach((primitive) => {
            if (!primitive.attributes || primitive.attributes.POSITION === undefined) return;

            const positionData = getAccessorArray(gltfData, buffers, primitive.attributes.POSITION);

            for (let i = 0; i < positionData.length; i += 3) {
              minX = Math.min(minX, positionData[i]);
              minY = Math.min(minY, positionData[i + 1]);
              minZ = Math.min(minZ, positionData[i + 2]);
              maxX = Math.max(maxX, positionData[i]);
              maxY = Math.max(maxY, positionData[i + 1]);
              maxZ = Math.max(maxZ, positionData[i + 2]);
            }

            let normalData;
            if (primitive.attributes.NORMAL !== undefined) {
              normalData = getAccessorArray(gltfData, buffers, primitive.attributes.NORMAL);
              if (!(normalData instanceof Float32Array)) normalData = new Float32Array(normalData);
            } else {
              normalData = new Float32Array((positionData.length / 3) * 3);
              for (let i = 0; i < normalData.length; i += 3) {
                normalData[i] = 0; normalData[i + 1] = 1; normalData[i + 2] = 0;
              }
            }

            let texcoordData = new Float32Array((positionData.length / 3) * 2);
            if (primitive.attributes.TEXCOORD_0 !== undefined) {
              let tc = getAccessorArray(gltfData, buffers, primitive.attributes.TEXCOORD_0);
              if (!(tc instanceof Float32Array)) tc = new Float32Array(tc);
              texcoordData = tc;
            }

            const arrays = { position: positionData, normal: normalData, texcoord: texcoordData };
            if (primitive.indices !== undefined) {
              arrays.indices = getAccessorArray(gltfData, buffers, primitive.indices);
            }

            const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, arrays);

            prims.push({
              bufferInfo,
              texture: getBaseColorTexForPrimitive(primitive),
            });
          });
        });

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const centerZ = (minZ + maxZ) / 2;
        const sizeX = maxX - minX;
        const sizeY = maxY - minY;
        const sizeZ = maxZ - minZ;
        const maxSize = Math.max(sizeX, sizeY, sizeZ);

        modelScale = maxSize > 0 ? 2.0 / maxSize : 1.0;
        modelOffset = [-centerX, -minY, -centerZ];

        console.log('GLTF primitives:', prims.length);
        return prims;
      }

      // file UI
      const fileInput = document.getElementById('gltfFile');
      const modelStatus = document.getElementById('modelStatus');

      fileInput.addEventListener('click', () => console.log('[GLTF] input clicked'));

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) { modelStatus.textContent = '선택 취소'; return; }

        try {
          modelStatus.textContent = '로딩중: ' + file.name;

          const { gltf, buffers } = await loadGLTF(file);
          gltfPrims = await parseGLTF(gltf, buffers);

          modelStatus.textContent = '로딩 완료: ' + file.name;
          render();
        } catch (err) {
          console.error(err);
          modelStatus.textContent = '로딩 실패: ' + err.message;
        }
      });

      // =========================
      // draw + render
      // =========================
      function drawScene(projectionMatrix, cameraMatrix, textureMatrix, lightWorldMatrix, programInfo) {
        const viewMatrix = m4.inverse(cameraMatrix);

        gl.useProgram(programInfo.program);

        webglUtils.setUniforms(programInfo, {
          u_view: viewMatrix,
          u_projection: projectionMatrix,
        });

        // for main program (ignored by depth program if uniforms not present)
        webglUtils.setUniforms(programInfo, {
          u_bias: settings.bias,
          u_textureMatrix: textureMatrix,
          u_projectedTexture: depthTexture,
          u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
        });

        // dlgmlals3
        /*
        // Sphere
        webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);
        webglUtils.setUniforms(programInfo, sphereUniforms);
        webglUtils.drawBufferInfo(gl, sphereBufferInfo);

        // Cube
        webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);
        webglUtils.setUniforms(programInfo, cubeUniforms);
        webglUtils.drawBufferInfo(gl, cubeBufferInfo);
        */
       
        // Plane
        webglUtils.setBuffersAndAttributes(gl, programInfo, planeBufferInfo);
        webglUtils.setUniforms(programInfo, planeUniforms);
        webglUtils.drawBufferInfo(gl, planeBufferInfo);

        // GLTF Model
        if (gltfPrims && gltfPrims.length) {
          let world = m4.identity();
          world = m4.translate(world, modelOffset[0], modelOffset[1], modelOffset[2]);
          world = m4.scale(world, modelScale, modelScale, modelScale);
          world = m4.translate(world, 0, 0.01, 0);

          for (const p of gltfPrims) {
            webglUtils.setBuffersAndAttributes(gl, programInfo, p.bufferInfo);

            webglUtils.setUniforms(programInfo, {
              u_colorMult: [1, 1, 1, 1],
              u_texture: (p.texture || whiteTexture), // ★ GLB baseColorTexture 우선
              u_world: world,
              u_color: [1, 1, 1, 1], // depth용
            });

            webglUtils.drawBufferInfo(gl, p.bufferInfo);
          }
        }
      }

      function render() {
        webglUtils.resizeCanvasToDisplaySize(gl.canvas);

        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);

        const lightWorldMatrix = m4.lookAt(
          [settings.posX, settings.posY, settings.posZ],
          [settings.targetX, settings.targetY, settings.targetZ],
          [0, 1, 0]
        );

        const lightProjectionMatrix = settings.perspective
          ? m4.perspective(degToRad(settings.fieldOfView), settings.projWidth / settings.projHeight, 0.5, 10)
          : m4.orthographic(
              -settings.projWidth / 2, settings.projWidth / 2,
              -settings.projHeight / 2, settings.projHeight / 2,
              0.5, 50
            );

        // Pass 1: Shadow map
        gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
        gl.viewport(0, 0, depthTextureSize, depthTextureSize);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        drawScene(lightProjectionMatrix, lightWorldMatrix, m4.identity(), lightWorldMatrix, colorProgramInfo);

        // Pass 2: Main render
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        let textureMatrix = m4.identity();
        textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
        textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
        textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);
        textureMatrix = m4.multiply(textureMatrix, m4.inverse(lightWorldMatrix));

        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projectionMatrix = m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
        const cameraPosition = [settings.cameraX, settings.cameraY, 15];
        const cameraMatrix = m4.lookAt(cameraPosition, [0, 0, 0], [0, 1, 0]);

        drawScene(projectionMatrix, cameraMatrix, textureMatrix, lightWorldMatrix, textureProgramInfo);

        // Frustum debug
        {
          gl.useProgram(colorProgramInfo.program);
          webglUtils.setBuffersAndAttributes(gl, colorProgramInfo, cubeLinesBufferInfo);

          const mat = m4.multiply(lightWorldMatrix, m4.inverse(lightProjectionMatrix));
          const viewMatrix = m4.inverse(cameraMatrix);

          webglUtils.setUniforms(colorProgramInfo, {
            u_color: [1, 1, 1, 1],
            u_view: viewMatrix,
            u_projection: projectionMatrix,
            u_world: mat,
          });

          webglUtils.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
        }
      }

      render();
    }

    main();
  </script>
</body>
</html>
