<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>원 크기 고정 테스트</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            font-family: monospace;
            color: #fff;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }
        #controls button {
            margin: 5px;
            padding: 10px 15px;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
            border-radius: 3px;
        }
        #controls button:hover {
            background: #555;
        }
        #controls button.active {
            background: #0a0;
            border-color: #0f0;
        }
        canvas {
            display: block;
            width: 100%;
            height: calc(100vh - 100px);
            border: 2px solid #333;
        }
        .info {
            margin: 10px 0;
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="info">해상도: <span id="resolution">-</span></div>
        <div class="info">종횡비: <span id="aspectRatio">-</span></div>
        <div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid #666;">
            <strong>방법 선택:</strong>
        </div>
        <button id="method1" onclick="setMethod(1)">방법 1: 기본 (문제있음)</button>
        <button id="method2" onclick="setMethod(2)">방법 2: 긴쪽 기준 정규화</button>
        <button id="method3" onclick="setMethod(3)">방법 3: 짧은쪽으로 나누기</button>
        <div style="margin: 10px 0; padding-top: 10px; border-top: 1px solid #666;">
            <strong>해상도 전환:</strong>
        </div>
        <button onclick="setSize(1920, 1080)">가로 (1920x1080)</button>
        <button onclick="setSize(1080, 1920)">세로 (1080x1920)</button>
        <button onclick="setSize(800, 800)">정사각형 (800x800)</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        let currentMethod = 1;

        // Vertex shader
        const vsSource = `
            attribute vec4 position;
            void main() {
                gl_Position = position;
            }
        `;

        // Fragment shader - 3가지 방법을 모두 포함
        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform int iMethod;

           void main() {
            vec2 uv;
            
            uv = (gl_FragCoord.xy / iResolution.xy) - 0.5;
            uv *= 2.0;
            uv.x *= iResolution.x / iResolution.y;
            
            float d = length(uv);
            
            // ⭐ Y축 변화를 보정!
            float radius = 0.3;
            radius *= min(iResolution.x, iResolution.y) / iResolution.y;
            
            
            float circle = smoothstep(radius + 0.01, radius - 0.01, d);
            
            vec3 color = vec3(circle);
            
            if (abs(uv.x) < 0.005 || abs(uv.y) < 0.005) {
                color = vec3(1.0, 0.0, 0.0);
            }
            
            gl_FragColor = vec4(color, 1.0);
        }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        const positionLoc = gl.getAttribLocation(program, 'position');
        const resolutionLoc = gl.getUniformLocation(program, 'iResolution');
        const methodLoc = gl.getUniformLocation(program, 'iMethod');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]), gl.STATIC_DRAW);

        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
            gl.uniform1i(methodLoc, currentMethod);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            updateInfo();
        }

        function setMethod(method) {
            currentMethod = method;
            document.querySelectorAll('#controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('method' + method).classList.add('active');
            render();
        }

        function setSize(w, h) {
            canvas.width = w;
            canvas.height = h;
            render();
        }

        function updateInfo() {
            document.getElementById('resolution').textContent = 
                canvas.width + ' x ' + canvas.height;
            document.getElementById('aspectRatio').textContent = 
                (canvas.width / canvas.height).toFixed(2);
        }

        // 초기화
        setSize(1920, 1080);
        setMethod(1);

        // 윈도우 리사이즈 대응
        window.addEventListener('resize', () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            render();
        });
    </script>
</body>
</html>