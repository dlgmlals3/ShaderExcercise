<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shadow Mapping with Lighting</title>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
        body {
            margin: 0;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .gman-widget-value {
            min-width: 5em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="uiContainer">
        <div id="ui"></div>
    </div>
    <!-- 
    dlgmlals3
    SoftShadow.html에서 사용하는 방식은 뎁스 버퍼를 사용한 방식이고
    z값이 저장된 값은 Perspective 투영을 거친 0~1 값이다.
    Perspective 카메라 투영의 특성상 가까운 곳은 촘촘하게 샘플링 되고, 먼 곳은 듬성 듬성 샘플링 되기 때문에
    실제 거리와 균등하지 않음 PCF, PCSS는 상관없지만 다른 알고리즘에서 비정상 동작


    View Space에서 Z값을 직접 전달하여 0~1 리니어 샘플링 하는 방법
    View Transform 기준은 카메라 원점 기준으로 되어있기 때문에 position.z 값은 카메라와 거리임 (light Space z)
    변환 행렬을 버텍스 셰이더에서 넘겨서 계산할때 사용하자.
    light space 기준으로 물체들을 그리기 위한 gl_position은 mvp를 통해서 그대로 보내고
    z 값은 카메라 변환 까지만하고 프러스텀 행렬은 곱하지 않고, varying을 통해서 프래그먼트 셰이더로 전달하자.
    near, far 기준으로 0~1 리니어 정규화를 하고 컬러버퍼에 저장한다.



    컬러 버퍼에 저장하는 방법~!!!!
    라이트 패스에 depth 뎁스 테스트가 필요하니깐 반드시 둘중 하나는 있어야함.'
    렌더버퍼는 샘플링이 안되는 임시 버퍼로 생각하자.
    1. Depth texture 
    - 뎁스 저장할 텍스처를 생성하고 DEPTH_ATTACHMENT로 붙임.
    2. Depth RednerBuffer
    - depth test를 통하여 어떤 프래그먼트가 살아남을지 결정은 해주지만 깊이값을 컬러로 지정해주지는 않음.

    기존 뎁스 Attach를 지우고, 프래그먼트 셰이더에서 gl_FragCoord.z 값 컬러로 Color 값에 저장을 할때
    렌더버퍼를 사용하지 않으면 compare를 하지 않고 바로 다 덮어써 버린다.

    -->
    <!-- vertex shader -->
    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec2 a_texcoord;
        attribute vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;
        uniform mat4 u_textureMatrix;

        varying vec2 v_texcoord;
        varying vec4 v_projectedTexcoord;
        varying vec3 v_normal;

        void main() {
            // Multiply the position by the matrix.
            vec4 worldPosition = u_world * a_position;
            gl_Position = u_projection * u_view * worldPosition;
            v_texcoord = a_texcoord;
            v_normal = mat3(u_world) * a_normal;

            // orient the normals and pass to the fragment shader
            v_projectedTexcoord = u_textureMatrix * worldPosition;
        }
    </script>

    <!-- fragment shader -->
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;

        // Passed in from the vertex shader.
        varying vec2 v_texcoord;
        varying vec4 v_projectedTexcoord;
        varying vec3 v_normal;

        uniform vec4 u_colorMult;
        uniform sampler2D u_texture;
        uniform sampler2D u_projectedTexture;
        uniform float u_bias;
        uniform vec3 u_reverseLightDirection;

        float hardShadow(vec3 projectedTexcoord, float currentDepth) {
            float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
            return (projectedDepth <= currentDepth) ? 0.0 : 1.0;            
        }
        
        float pcssShadow(vec3 projectedTexcoord, float currentDepth) {
            // blocker는 내 픽셀 주변에 가리고 있는 물체를 의미.
            // blocker 가 많다 -> 주변에 빛을 가리는 물체가 넓게 분포
            
            // Step 1: Blocker Search - 내 픽셀 주변 평균 blocker 깊이 찾기
            vec2 texelSize = vec2(0.001, 0.001);
                        
            float blockerDepthSum = 0.0;
            float blockerCount = 0.0;
            const float searchWidth = 30.0;  // 탐색 범위
            
            for (float x = -searchWidth; x <= searchWidth; x++) {
                for (float y = -searchWidth; y <= searchWidth; y++) {
                    vec2 offset = vec2(float(x), float(y)) * texelSize;
                    float shadowMapDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                    
                    // blocker인지 확인 (그림자를 만드는 깊이)
                    if (shadowMapDepth < currentDepth) {
                        blockerDepthSum += shadowMapDepth;
                        blockerCount += 1.0;
                    }
                }
            }            
            // blocker가 없으면 그림자 없고, 모든 픽셀이 다 블록되면 하드쉐도우
            if (blockerCount < 1.0) {
                return 1.0;
            }            

            // 평균 blocker 깊이
            float avgBlockerDepth = blockerDepthSum / blockerCount;
            
            // blocker 가까운 곳 -> 선명한 그림자 (umbra)
            // avgBlockerDepth = 0.7, currentDepth = 0.8, 
            // 거리 = 0.8 - 0.7 = 0.1 (작은 차이) → Blocker가 나랑 가까움 → 선명한 그림자            
            
            // blocker 먼 곳 -> 부드러운 그림자 (penumbra)
            // avgBlockerDepth = 0.2, currentDepth = 0.8
            // 거리 = 0.8 - 0.2 = 0.6 (큰 차이) -> Blocker가 나랑 멀리 → 부드러운 그림자
            
            /////////////////////////////////////////////////////////

            // Step 2: Penumbra 영역 구함 (반그림자 크기)
            float lightSize = 120.05;  // 광원 크기 (조정 가능)
            float penumbra = (currentDepth - avgBlockerDepth) / avgBlockerDepth * lightSize;
            
            // penumbra에 비례하여 필터 크기 조정
            float filterRadius = penumbra * 100.0;  // 스케일 조정
            filterRadius = clamp(filterRadius, 1.0, 5.0);  // 최소/최대 제한
            /////////////////////////////////////////////////////

            // Step 3: PCF with variable kernel size
            float shadow = 0.0;
            float samples = 0.0;
                        
            for (float x = -5.0; x <= 5.0; x++) {
                for (float y = -5.0; y <= 5.0; y++) {
                    if (abs(float(x)) <= filterRadius && abs(float(y)) <= filterRadius) {
                        vec2 offset = vec2(float(x), float(y)) * texelSize;
                        float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                        
                        shadow += (projectedDepth <= currentDepth) ? 0.0 : 1.0;
                        samples += 1.0;
                    }
                }
            }
            return shadow / samples;
        }


        float pcfShadow(vec3 projectedTexcoord, float currentDepth) {
            // 텍셀 크기 (고정값)
            vec2 texelSize = vec2(0.001, 0.001);
            
            float shadow = 0.0;
            
            // 3x3 PCF 커널
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    vec2 offset = vec2(float(x), float(y)) * texelSize;
                    float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                    
                    // 현재 픽셀이 그림자 안에 있는지 확인
                    shadow += (projectedDepth <= currentDepth) ? 0.0 : 1.0;
                }
            }
            
            // 평균 계산 (9개 샘플)
            return shadow / 9.0;
        }

        void main() {
            // because v_normal is a varying it's interpolated
            // so it will not be a unit vector. Normalizing it
            // will make it a unit vector again
            vec3 normal = normalize(v_normal);

            float light = dot(normal, u_reverseLightDirection);            
            vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;            
            // projectedTexcoord = projectedTexcoord * 0.5 + 0.5;  // 텍스처 좌표로 변환

            float currentDepth = projectedTexcoord.z - u_bias;

            bool inRange =
                projectedTexcoord.x >= 0.0 &&
                projectedTexcoord.x <= 1.0 &&
                projectedTexcoord.y >= 0.0 &&
                projectedTexcoord.y <= 1.0;

            // the 'r' channel has the depth values
  
            float shadowLight;
            if (inRange) {
                shadowLight = hardShadow(projectedTexcoord, currentDepth);
                //shadowLight = pcfShadow(projectedTexcoord, currentDepth);
                //shadowLight = pcssShadow(projectedTexcoord, currentDepth);
            } else {
                shadowLight = 1.0;
            }
            
            vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
            gl_FragColor = vec4(
                texColor.rgb * light * shadowLight,
                texColor.a);
        }
    </script>
    
    <!-- vertex shader -->
    <script id="color-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;

        varying float v_viewZ; // dlgmlals3

        void main() {
            // Multiply the position by the matrices.
            vec4 worldPosition = u_world * a_position; 
            vec4 viewPosition = u_view * worldPosition;
            
            v_viewZ = -viewPosition.z;
            gl_Position = u_projection * viewPosition;
        }
    </script>

    
    <!-- fragment shader -->
    <script id="color-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        // dlgmlals3
        uniform vec4 u_color;
        uniform float u_near;
        uniform float u_far;

        varying float v_viewZ;

        void main() {
            float linearDepth = (v_viewZ - u_near) / (u_far - u_near);
            linearDepth = clamp(linearDepth, 0.0, 1.0);
            gl_FragColor = vec4(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z, 1.0);
        }
    </script>

    <!-- External libraries -->
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>

    <!-- Main JavaScript -->
    <script>
        'use strict';

        function main() {
            // Get A WebGL context
            /** @type {HTMLCanvasElement} */
            const canvas = document.querySelector('#canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                return;
            }
            
            // setup GLSL programs
            const textureProgramInfo = webglUtils.createProgramInfo(gl, ['vertex-shader-3d', 'fragment-shader-3d']);
            const colorProgramInfo = webglUtils.createProgramInfo(gl, ['color-vertex-shader', 'color-fragment-shader']);

            const sphereBufferInfo = primitives.createSphereBufferInfo(
                gl,
                1,  // radius
                32, // subdivisions around
                24, // subdivisions down
            );
            const planeBufferInfo = primitives.createPlaneBufferInfo(
                gl,
                20,  // width
                20,  // height
                1,   // subdivisions across
                1,   // subdivisions down
            );
            const cubeBufferInfo = primitives.createCubeBufferInfo(
                gl,
                2,  // size
            );
            const cubeLinesBufferInfo = webglUtils.createBufferInfoFromArrays(gl, {
                position: [
                    -1, -1, -1,
                     1, -1, -1,
                    -1,  1, -1,
                     1,  1, -1,
                    -1, -1,  1,
                     1, -1,  1,
                    -1,  1,  1,
                     1,  1,  1,
                ],
                indices: [
                    0, 1,
                    1, 3,
                    3, 2,
                    2, 0,

                    4, 5,
                    5, 7,
                    7, 6,
                    6, 4,

                    0, 4,
                    1, 5,
                    3, 7,
                    2, 6,
                ],
            });

            // make a 8x8 checkerboard texture
            const checkerboardTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,                // mip level
                gl.LUMINANCE,     // internal format
                8,                // width
                8,                // height
                0,                // border
                gl.LUMINANCE,     // format
                gl.UNSIGNED_BYTE, // type
                new Uint8Array([  // data
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                ]));
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const depthTexture = gl.createTexture();

            const depthTextureSize = 512;

            gl.bindTexture(gl.TEXTURE_2D, depthTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,      // target
                0,                  // mip level
                gl.RGBA, // internal format
                depthTextureSize,   // width
                depthTextureSize,   // height
                0,                  // border
                gl.RGBA, // format
                gl.UNSIGNED_BYTE,    // type
                null);              // data
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // dlgmlals3 2
            // 뎁스 어태치 지우고 컬러 버퍼 어태치
            const depthFramebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,       // target
                gl.COLOR_ATTACHMENT0,  // attachment point
                gl.TEXTURE_2D,        // texture target
                depthTexture,         // texture
                0);                   // mip level

            const depthRenderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderbuffer);
            gl.renderbufferStorage(
                gl.RENDERBUFFER,
                gl.DEPTH_COMPONENT16,
                depthTextureSize,
                depthTextureSize
            );
            gl.framebufferRenderbuffer(
                gl.FRAMEBUFFER,
                gl.DEPTH_ATTACHMENT,
                gl.RENDERBUFFER,
                depthRenderbuffer
            );

            function degToRad(d) {
                return d * Math.PI / 180;
            }
            // dlgmlals3
            const settings = {
                cameraX: 6,
                cameraY: 12,
                lightNear: 0.5,   // perspective near
                lightFar: 10,     // perspective far                
                posX: 2.5,
                posY: 4.8,
                posZ: 7,
                targetX: 3.5,
                targetY: 0,
                targetZ: 3.5,
                projWidth: 10,
                projHeight: 10,
                perspective: false,
                fieldOfView: 120,                
                bias: 0.04,
            };
            webglLessonsUI.setupUI(document.querySelector('#ui'), settings, [
                { type: 'slider',   key: 'cameraX',    min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'cameraY',    min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posX',       min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posY',       min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posZ',       min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetX',    min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetY',    min:   0, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetZ',    min: -10, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'projWidth',  min:   0, max: 100, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'projHeight', min:   0, max: 100, change: render, precision: 2, step: 0.001, },
                { type: 'checkbox', key: 'perspective', change: render, },
                { type: 'slider',   key: 'fieldOfView', min:  1, max: 179, change: render, },
                { type: 'slider',   key: 'bias',       min:  0.0, max: 0.1, change: render, precision: 4, step: 0.001, },
                { type: 'slider',   key: 'lightNear', min: 0.1, max: 5, change: render, precision: 2, step: 0.1 },
                { type: 'slider',   key: 'lightFar', min: 5, max: 50, change: render, precision: 1, step: 1 },                
            ]);

            const fieldOfViewRadians = degToRad(60);

            // Uniforms for each object.
            const planeUniforms = {
                u_colorMult: [0.5, 0.5, 1, 1],  // lightblue
                u_color: [1, 0, 0, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(0, 0, 0),
            };
            const sphereUniforms = {
                u_colorMult: [1, 0.5, 0.5, 1],  // pink
                u_color: [0, 0, 1, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(2, 3, 4),
            };
            const cubeUniforms = {
                u_colorMult: [0.5, 1, 0.5, 1],  // lightgreen
                u_color: [0, 0, 1, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(3, 1, 0),
            };
            
            function drawScene(
                projectionMatrix,
                cameraMatrix,
                textureMatrix,
                lightWorldMatrix,
                programInfo) {
                // Make a view matrix from the camera matrix.
                const viewMatrix = m4.inverse(cameraMatrix);

                gl.useProgram(programInfo.program);

                // set uniforms that are the same for both the sphere and plane
                webglUtils.setUniforms(programInfo, {
                    u_view: viewMatrix,
                    u_projection: projectionMatrix,
                    u_bias: settings.bias,
                    u_textureMatrix: textureMatrix,
                    u_projectedTexture: depthTexture,
                    u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
                });
            
                const commonUniforms = {
                    u_view: viewMatrix,
                    u_projection: projectionMatrix,
                    u_bias: settings.bias,
                    u_textureMatrix: textureMatrix,
                    u_projectedTexture: depthTexture,
                    u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
                };
                
                if (programInfo === colorProgramInfo) {
                    commonUniforms.u_near = settings.lightNear;
                    commonUniforms.u_far = settings.lightFar;
                }
                
                webglUtils.setUniforms(programInfo, commonUniforms);

                // ------ Draw the sphere --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);
                webglUtils.setUniforms(programInfo, sphereUniforms);
                webglUtils.drawBufferInfo(gl, sphereBufferInfo);

                // ------ Draw the cube --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);
                webglUtils.setUniforms(programInfo, cubeUniforms);
                webglUtils.drawBufferInfo(gl, cubeBufferInfo);

                // ------ Draw the plane --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, planeBufferInfo);
                webglUtils.setUniforms(programInfo, planeUniforms);
                webglUtils.drawBufferInfo(gl, planeBufferInfo);

    
                const fileInput = document.getElementById('gltfFile');
                console.log('File input element:', fileInput);
                
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        console.log('=== FILE SELECTED ===');
                        console.log('Event:', e);
                        console.log('Files:', e.target.files);
                        console.log('File count:', e.target.files.length);
                        
                        if (e.target.files[0]) {
                            console.log('File name:', e.target.files[0].name);
                            console.log('File size:', e.target.files[0].size);
                            console.log('File type:', e.target.files[0].type);
                            
                            document.getElementById('modelStatus').textContent = 
                                '파일 선택됨: ' + e.target.files[0].name;
                        }
                    });
                    console.log('Event listener attached!');
                } else {
                    console.error('File input NOT FOUND!');
                }
                console.log('Script loaded!');
        
            }
 
            // Draw the scene.
            function render() {
                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                // first draw from the POV of the light
                const lightWorldMatrix = m4.lookAt(
                    [settings.posX, settings.posY, settings.posZ],          // position
                    [settings.targetX, settings.targetY, settings.targetZ], // target
                    [0, 1, 0],                                              // up
                );
                // orthographic : direction light
                // perspective : 원근이 적용된 그림자. ( spot light )
                const lightProjectionMatrix = settings.perspective
                    ? m4.perspective(
                        degToRad(settings.fieldOfView),
                        settings.projWidth / settings.projHeight,
                        settings.lightNear,  // near
                        settings.lightFar)   // far
                    : m4.orthographic(
                        -settings.projWidth / 2,   // left
                         settings.projWidth / 2,   // right
                        -settings.projHeight / 2,  // bottom
                         settings.projHeight / 2,  // top
                         settings.lightNear,                      // near
                         settings.lightFar);                      // far

                // draw to the depth texture                
                gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
                
                
                //gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.viewport(0, 0, depthTextureSize, depthTextureSize);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                drawScene(
                    lightProjectionMatrix,
                    lightWorldMatrix,
                    m4.identity(),
                    lightWorldMatrix,
                    colorProgramInfo);

                // now draw scene to the canvas projecting the depth texture into the scene                

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                let textureMatrix = m4.identity();
                                
                // lightPos.x, lightPos.y ==> 뎁스 텍스처의 샘플링을 위한 st
                // lightPos.z = light와 픽셀간 depth 값

                // 프래그먼트 셰이더에서 아래처럼 해도 됨.
                //vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;  // NDC로 변환
                //shadowCoord = shadowCoord * 0.5 + 0.5;  // 텍스처 좌표로 변환
                
                //[0.5  0    0    0.5]   [a    0    0    0  ]
                //[0    0.5  0    0.5] × [0    b    0    0  ]
                //[0    0    0.5  0.5]   [0    0    c    d  ]
                //[0    0    0    1  ]   [0    0    0    1  ]

                //결과:
                //[0.5a   0      0      0.5]
                //[0      0.5b   0      0.5]
                //[0      0      0.5c   0.5+0.5d]
                //[0      0      0      1  ]                
                
                textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
                textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);

                textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);

                textureMatrix = m4.multiply(
                    textureMatrix,
                    m4.inverse(lightWorldMatrix));


                // Compute the projection matrix
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const projectionMatrix =
                    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

                // Compute the camera's matrix using look at.
                const cameraPosition = [settings.cameraX, settings.cameraY, 15];
                const target = [0, 0, 0];
                const up = [0, 1, 0];
                // camera world space
                const cameraMatrix = m4.lookAt(cameraPosition, target, up);

                drawScene(
                    projectionMatrix,
                    cameraMatrix,
                    textureMatrix,
                    lightWorldMatrix,
                    textureProgramInfo);

                // ------ Draw the frustum ------
                {
                    gl.useProgram(colorProgramInfo.program);
                    // CubeLinesBufferInfo 
                    // NDC 공간으로 가정 -1 ~ +1
                    // NDC 공간에 큐브를 카메라가 보는 프러스텀 모양으로 월드에 그리기
                    webglUtils.setBuffersAndAttributes(gl, colorProgramInfo, cubeLinesBufferInfo);
                    
                    // 1. NDC -> Light View(카메라) 공간으로 되돌리기 inverse(lightProjectionMatrix)                                        
                    // 2. lightWorldMatrix --> 카메라 -> 월드
                    //  - m4.inverse(lightWorldMatrix) --> 월드 -> 카메라 공간
                    const mat = m4.multiply(
                        lightWorldMatrix, m4.inverse(lightProjectionMatrix));
                    
                    const viewMatrix = m4.inverse(cameraMatrix);

                    // dlgmlals3
                    webglUtils.setUniforms(colorProgramInfo, {
                        u_color: [1, 1, 1, 1],

                        u_view: viewMatrix,
                        u_projection: projectionMatrix,
                        u_world: mat,
                    });

                    webglUtils.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
                }
            }
            
            render();
        }

        main();
    </script>
</body>
</html>