<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shadow Mapping with Lighting</title>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
        body {
            margin: 0;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .gman-widget-value {
            min-width: 5em;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="uiContainer">
        <div id="ui"></div>
    </div>
    // dlgmlals6 6.1) 리얼 렌더링 셰이더
    <!-- vertex shader -->
    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec2 a_texcoord;
        attribute vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;
        uniform mat4 u_textureMatrix;

        varying vec2 v_texcoord;
        varying vec4 v_projectedTexcoord;
        varying vec3 v_normal;

        void main() {
            // Multiply the position by the matrix.
            vec4 worldPosition = u_world * a_position;
            gl_Position = u_projection * u_view * worldPosition;
            v_texcoord = a_texcoord;
            v_normal = mat3(u_world) * a_normal;

            // orient the normals and pass to the fragment shader
            v_projectedTexcoord = u_textureMatrix * worldPosition;
        }
    </script>

    <!-- fragment shader -->
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;

        // Passed in from the vertex shader.
        varying vec2 v_texcoord;
        varying vec4 v_projectedTexcoord;
        varying vec3 v_normal;

        uniform vec4 u_colorMult;
        uniform sampler2D u_texture;
        uniform sampler2D u_projectedTexture;
        uniform float u_bias;
        uniform vec3 u_reverseLightDirection;

        float hardShadow(vec3 projectedTexcoord, float currentDepth) {
            float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
            return (projectedDepth <= currentDepth) ? 0.0 : 1.0;            
        }
        
        // dlgmlals3 10
        float pcssShadow(vec3 projectedTexcoord, float currentDepth) {
            // blocker는 내 픽셀 주변에 가리고 있는 물체를 의미.
            // blocker 가 많다 -> 주변에 빛을 가리는 물체가 넓게 분포
            
            // Step 1: Blocker Search - 내 픽셀 주변 평균 blocker 깊이 찾기
            vec2 texelSize = vec2(0.001, 0.001);
                        
            float blockerDepthSum = 0.0;
            float blockerCount = 0.0;
            const float searchWidth = 30.0;  // 탐색 범위
            
            for (float x = -searchWidth; x <= searchWidth; x++) {
                for (float y = -searchWidth; y <= searchWidth; y++) {
                    vec2 offset = vec2(float(x), float(y)) * texelSize;
                    float shadowMapDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                    
                    // blocker인지 확인 (그림자를 만드는 깊이)
                    if (shadowMapDepth < currentDepth) {
                        blockerDepthSum += shadowMapDepth;
                        blockerCount += 1.0;
                    }
                }
            }            
            // blocker가 없으면 그림자 없고, 모든 픽셀이 다 블록되면 하드쉐도우
            if (blockerCount < 1.0) {
                return 1.0;
            }            

            // 평균 blocker 깊이
            float avgBlockerDepth = blockerDepthSum / blockerCount;
            
            // blocker 가까운 곳 -> 선명한 그림자 (umbra)
            // avgBlockerDepth = 0.7, currentDepth = 0.8, 
            // 거리 = 0.8 - 0.7 = 0.1 (작은 차이) → Blocker가 나랑 가까움 → 선명한 그림자            
            
            // blocker 먼 곳 -> 부드러운 그림자 (penumbra)
            // avgBlockerDepth = 0.2, currentDepth = 0.8
            // 거리 = 0.8 - 0.2 = 0.6 (큰 차이) -> Blocker가 나랑 멀리 → 부드러운 그림자
            
            /////////////////////////////////////////////////////////

            // Step 2: Penumbra 영역 구함 (반그림자 크기)
            float lightSize = 120.05;  // 광원 크기 (조정 가능)
            float penumbra = (currentDepth - avgBlockerDepth) / avgBlockerDepth * lightSize;
            
            // penumbra에 비례하여 필터 크기 조정
            float filterRadius = penumbra * 100.0;  // 스케일 조정
            filterRadius = clamp(filterRadius, 1.0, 5.0);  // 최소/최대 제한
            /////////////////////////////////////////////////////

            // Step 3: PCF with variable kernel size
            float shadow = 0.0;
            float samples = 0.0;
                        
            for (float x = -5.0; x <= 5.0; x++) {
                for (float y = -5.0; y <= 5.0; y++) {
                    if (abs(float(x)) <= filterRadius && abs(float(y)) <= filterRadius) {
                        vec2 offset = vec2(float(x), float(y)) * texelSize;
                        float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                        
                        shadow += (projectedDepth <= currentDepth) ? 0.0 : 1.0;
                        samples += 1.0;
                    }
                }
            }
            return shadow / samples;
        }


        // dlgmlals3 9
        float pcfShadow(vec3 projectedTexcoord, float currentDepth) {
            // 텍셀 크기 (고정값)
            vec2 texelSize = vec2(0.001, 0.001);
            
            float shadow = 0.0;
            
            // 3x3 PCF 커널
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    vec2 offset = vec2(float(x), float(y)) * texelSize;
                    float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy + offset).r;
                    
                    // 현재 픽셀이 그림자 안에 있는지 확인
                    shadow += (projectedDepth <= currentDepth) ? 0.0 : 1.0;
                }
            }
            
            // 평균 계산 (9개 샘플)
            return shadow / 9.0;
        }

        void main() {
            // because v_normal is a varying it's interpolated
            // so it will not be a unit vector. Normalizing it
            // will make it a unit vector again
            vec3 normal = normalize(v_normal);

            float light = dot(normal, u_reverseLightDirection);            
            vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
            // dlgmlals3 5.1
            // projectedTexcoord = projectedTexcoord * 0.5 + 0.5;  // 텍스처 좌표로 변환

            float currentDepth = projectedTexcoord.z - u_bias;

            bool inRange =
                projectedTexcoord.x >= 0.0 &&
                projectedTexcoord.x <= 1.0 &&
                projectedTexcoord.y >= 0.0 &&
                projectedTexcoord.y <= 1.0;

            // the 'r' channel has the depth values
  
            float shadowLight;
            if (inRange) {
                //shadowLight = hardShadow(projectedTexcoord, currentDepth);
                //shadowLight = pcfShadow(projectedTexcoord, currentDepth);
                shadowLight = pcssShadow(projectedTexcoord, currentDepth);
            } else {
                shadowLight = 1.0;
            }
            
            vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
            gl_FragColor = vec4(
                texColor.rgb * light * shadowLight,
                texColor.a);
        }
    </script>

    // dlgmlals6 3.1 뎁스 버퍼 렌더링
    <!-- vertex shader -->
    <script id="color-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;

        void main() {
            // Multiply the position by the matrices.
            gl_Position = u_projection * u_view * u_world * a_position;
        }
    </script>

    <!-- fragment shader -->
    <script id="color-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color; // for debug
        }
    </script>

    <!-- External libraries -->
    <script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/primitives.js"></script>

    <!-- Main JavaScript -->
    <script>
        'use strict';

        function main() {
            // Get A WebGL context
            /** @type {HTMLCanvasElement} */
            const canvas = document.querySelector('#canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                return;
            }

            const ext = gl.getExtension('WEBGL_depth_texture');
            if (!ext) {
                return alert('need WEBGL_depth_texture');
            }

            // setup GLSL programs
            const textureProgramInfo = webglUtils.createProgramInfo(gl, ['vertex-shader-3d', 'fragment-shader-3d']);
            const colorProgramInfo = webglUtils.createProgramInfo(gl, ['color-vertex-shader', 'color-fragment-shader']);

            const sphereBufferInfo = primitives.createSphereBufferInfo(
                gl,
                1,  // radius
                32, // subdivisions around
                24, // subdivisions down
            );
            const planeBufferInfo = primitives.createPlaneBufferInfo(
                gl,
                20,  // width
                20,  // height
                1,   // subdivisions across
                1,   // subdivisions down
            );
            const cubeBufferInfo = primitives.createCubeBufferInfo(
                gl,
                2,  // size
            );
            const cubeLinesBufferInfo = webglUtils.createBufferInfoFromArrays(gl, {
                position: [
                    -1, -1, -1,
                     1, -1, -1,
                    -1,  1, -1,
                     1,  1, -1,
                    -1, -1,  1,
                     1, -1,  1,
                    -1,  1,  1,
                     1,  1,  1,
                ],
                indices: [
                    0, 1,
                    1, 3,
                    3, 2,
                    2, 0,

                    4, 5,
                    5, 7,
                    7, 6,
                    6, 4,

                    0, 4,
                    1, 5,
                    3, 7,
                    2, 6,
                ],
            });

            // make a 8x8 checkerboard texture
            const checkerboardTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,
                0,                // mip level
                gl.LUMINANCE,     // internal format
                8,                // width
                8,                // height
                0,                // border
                gl.LUMINANCE,     // format
                gl.UNSIGNED_BYTE, // type
                new Uint8Array([  // data
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                    0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
                    0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
                ]));
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            const depthTexture = gl.createTexture();
            
            // dlgmlals3 7.4            
            // dlgmlals3 9            
            const depthTextureSize = 512;

            gl.bindTexture(gl.TEXTURE_2D, depthTexture);
            gl.texImage2D(
                gl.TEXTURE_2D,      // target
                0,                  // mip level
                gl.DEPTH_COMPONENT, // internal format
                depthTextureSize,   // width
                depthTextureSize,   // height
                0,                  // border
                gl.DEPTH_COMPONENT, // format
                gl.UNSIGNED_INT,    // type
                null);              // data
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // dlgmlals3 2
            // 뎁스 텍스처를 프레임버퍼에 붙임
            const depthFramebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
            gl.framebufferTexture2D(
                gl.FRAMEBUFFER,       // target
                gl.DEPTH_ATTACHMENT,  // attachment point
                gl.TEXTURE_2D,        // texture target
                depthTexture,         // texture
                0);                   // mip level

            function degToRad(d) {
                return d * Math.PI / 180;
            }

            const settings = {
                cameraX: 6,
                cameraY: 12,
                posX: 2.5,
                posY: 4.8,
                posZ: 7,
                targetX: 3.5,
                targetY: 0,
                targetZ: 3.5,
                projWidth: 10,
                projHeight: 10,
                perspective: false,
                fieldOfView: 120,
                // dlgmlals3 bias control -> small -> big
                bias: 0.04,
            };
            webglLessonsUI.setupUI(document.querySelector('#ui'), settings, [
                { type: 'slider',   key: 'cameraX',    min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'cameraY',    min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posX',       min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posY',       min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'posZ',       min:   1, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetX',    min: -10, max: 10, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetY',    min:   0, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'targetZ',    min: -10, max: 20, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'projWidth',  min:   0, max: 100, change: render, precision: 2, step: 0.001, },
                { type: 'slider',   key: 'projHeight', min:   0, max: 100, change: render, precision: 2, step: 0.001, },
                { type: 'checkbox', key: 'perspective', change: render, },
                { type: 'slider',   key: 'fieldOfView', min:  1, max: 179, change: render, },
                { type: 'slider',   key: 'bias',       min:  0.0, max: 0.1, change: render, precision: 4, step: 0.001, },
            ]);

            const fieldOfViewRadians = degToRad(60);

            // Uniforms for each object.
            const planeUniforms = {
                u_colorMult: [0.5, 0.5, 1, 1],  // lightblue
                u_color: [1, 0, 0, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(0, 0, 0),
            };
            const sphereUniforms = {
                u_colorMult: [1, 0.5, 0.5, 1],  // pink
                u_color: [0, 0, 1, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(2, 3, 4),
            };
            const cubeUniforms = {
                u_colorMult: [0.5, 1, 0.5, 1],  // lightgreen
                u_color: [0, 0, 1, 1],
                u_texture: checkerboardTexture,
                u_world: m4.translation(3, 1, 0),
            };

            function drawScene(
                projectionMatrix,
                cameraMatrix,
                textureMatrix,
                lightWorldMatrix,
                programInfo) {
                // Make a view matrix from the camera matrix.
                const viewMatrix = m4.inverse(cameraMatrix);

                gl.useProgram(programInfo.program);

                // set uniforms that are the same for both the sphere and plane
                webglUtils.setUniforms(programInfo, {
                    u_view: viewMatrix,
                    u_projection: projectionMatrix,
                    u_bias: settings.bias,
                    u_textureMatrix: textureMatrix,
                    u_projectedTexture: depthTexture,
                    u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
                });

                // ------ Draw the sphere --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, sphereBufferInfo);
                webglUtils.setUniforms(programInfo, sphereUniforms);
                webglUtils.drawBufferInfo(gl, sphereBufferInfo);

                // ------ Draw the cube --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, cubeBufferInfo);
                webglUtils.setUniforms(programInfo, cubeUniforms);
                webglUtils.drawBufferInfo(gl, cubeBufferInfo);

                // ------ Draw the plane --------
                webglUtils.setBuffersAndAttributes(gl, programInfo, planeBufferInfo);
                webglUtils.setUniforms(programInfo, planeUniforms);
                webglUtils.drawBufferInfo(gl, planeBufferInfo);
            }
 
            // Draw the scene.
            function render() {
                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.DEPTH_TEST);

                // first draw from the POV of the light
                const lightWorldMatrix = m4.lookAt(
                    [settings.posX, settings.posY, settings.posZ],          // position
                    [settings.targetX, settings.targetY, settings.targetZ], // target
                    [0, 1, 0],                                              // up
                );
                // dlgmlals3 2
                // orthographic : direction light
                // perspective : 원근이 적용된 그림자. ( spot light )
                const lightProjectionMatrix = settings.perspective
                    ? m4.perspective(
                        degToRad(settings.fieldOfView),
                        settings.projWidth / settings.projHeight,
                        0.5,  // near
                        10)   // far
                    : m4.orthographic(
                        -settings.projWidth / 2,   // left
                         settings.projWidth / 2,   // right
                        -settings.projHeight / 2,  // bottom
                         settings.projHeight / 2,  // top
                         0.5,                      // near
                         50);                      // far

                // dlgmlals3 2
                // draw to the depth texture
                // dlgmlals3 디버깅할때 메인 프레임 버퍼로 설정해서 라이트 시점에 렌더링 확인            
                gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
                
                // dlgmlals3 7.0
                //gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                gl.viewport(0, 0, depthTextureSize, depthTextureSize);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                drawScene(
                    lightProjectionMatrix,
                    lightWorldMatrix,
                    m4.identity(),
                    lightWorldMatrix,
                    colorProgramInfo);

                // now draw scene to the canvas projecting the depth texture into the scene
                // dlgmlals3 4 : 메인 프레임버퍼 바인딩

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                let textureMatrix = m4.identity();
                
                // dlgmlals3 5 : Vec3 LightPos 계산
                // lightPos.x, lightPos.y ==> 뎁스 텍스처의 샘플링을 위한 st
                // lightPos.z = light와 픽셀간 depth 값

                // 프래그먼트 셰이더에서 아래처럼 해도 됨.
                //vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;  // NDC로 변환
                //shadowCoord = shadowCoord * 0.5 + 0.5;  // 텍스처 좌표로 변환
                
                //[0.5  0    0    0.5]   [a    0    0    0  ]
                //[0    0.5  0    0.5] × [0    b    0    0  ]
                //[0    0    0.5  0.5]   [0    0    c    d  ]
                //[0    0    0    1  ]   [0    0    0    1  ]

                //결과:
                //[0.5a   0      0      0.5]
                //[0      0.5b   0      0.5]
                //[0      0      0.5c   0.5+0.5d]
                //[0      0      0      1  ]                
                
                // dlgmlals3 5.1 light space를 위한 역변환 
                textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
                textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);

                textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);

                textureMatrix = m4.multiply(
                    textureMatrix,
                    m4.inverse(lightWorldMatrix));


                // Compute the projection matrix
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const projectionMatrix =
                    m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

                // Compute the camera's matrix using look at.
                const cameraPosition = [settings.cameraX, settings.cameraY, 15];
                const target = [0, 0, 0];
                const up = [0, 1, 0];
                // camera world space
                const cameraMatrix = m4.lookAt(cameraPosition, target, up);

                drawScene(
                    projectionMatrix,
                    cameraMatrix,
                    textureMatrix,
                    lightWorldMatrix,
                    textureProgramInfo);

                // dlgmlals3 8 프러스텀 라인 렌더링
                // ------ Draw the frustum ------
                {
                    gl.useProgram(colorProgramInfo.program);
                    // CubeLinesBufferInfo 
                    // NDC 공간으로 가정 -1 ~ +1
                    // NDC 공간에 큐브를 카메라가 보는 프러스텀 모양으로 월드에 그리기
                    webglUtils.setBuffersAndAttributes(gl, colorProgramInfo, cubeLinesBufferInfo);
                    
                    // 1. NDC -> Light View(카메라) 공간으로 되돌리기 inverse(lightProjectionMatrix)                                        
                    // 2. lightWorldMatrix --> 카메라 -> 월드
                    //  - m4.inverse(lightWorldMatrix) --> 월드 -> 카메라 공간
                    const mat = m4.multiply(
                        lightWorldMatrix, m4.inverse(lightProjectionMatrix));
                    
                    const viewMatrix = m4.inverse(cameraMatrix);

                    webglUtils.setUniforms(colorProgramInfo, {
                        u_color: [1, 1, 1, 1],
                        u_view: viewMatrix,
                        u_projection: projectionMatrix,
                        u_world: mat,
                    });

                    webglUtils.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
                }
            }
            // dlgmlals3 7.0) 뎁스 카메라 잘보이는 것 확인
            render();
        }

        main();
    </script>
</body>
</html>