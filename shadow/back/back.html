


<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL PCSS Soft Shadows</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            background: #000;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .controls {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .control-group {
            margin: 15px 0;
        }
        label {
            display: inline-block;
            width: 200px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 300px;
        }
        .value {
            display: inline-block;
            width: 80px;
            text-align: right;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <h2>PCSS 소프트 쉐도우 설정</h2>
        
        <div class="control-group">
            <label>GLTF 모델 로드:</label>
            <input type="file" id="gltfFile" accept=".gltf,.glb">
            <span class="value" id="modelStatus">모델 없음</span>
        </div>
                
        <div class="control-group">
            <label>모델 Y 위치:</label>
            <input type="range" id="modelY" min="-1" max="1" step="0.001" value="0">
            <span class="value" id="modelYValue">0.000</span>
        </div>
        
        <div class="control-group">
            <label>쉐도우맵 디버그:</label>
            <input type="checkbox" id="debugShadow">
        </div>
        
        <div class="control-group">
            <label>Light Size:</label>
            <input type="range" id="lightSize" min="0.001" max="0.05" step="0.001" value="0.01">
            <span class="value" id="lightSizeValue">0.01</span>
        </div>
        
        <div class="control-group">
            <label>Shadow Samples:</label>
            <input type="range" id="samples" min="8" max="64" step="4" value="32">
            <span class="value" id="samplesValue">32</span>
        </div>
        
        <div class="control-group">
            <label>Light Height:</label>
            <input type="range" id="lightHeight" min="2" max="10" step="0.1" value="3">
            <span class="value" id="lightHeightValue">3</span>
        </div>
        
        <div class="control-group">
            <label>Light Rotation:</label>
            <input type="range" id="lightRotation" min="0" max="360" step="1" value="45">
            <span class="value" id="lightRotationValue">45°</span>
        </div>
    </div>

    <script>
        // dlgmlals3
        const debuggingRendering = false;

        const frustumVertexShader = `
            attribute vec3 aPosition;
            uniform mat4 uMVP;
            
            void main() {
                gl_Position = uMVP * vec4(aPosition, 1.0);
            }
        `;

        const frustumFragmentShader = `
            precision highp float;
            uniform vec3 uColor;
            
            void main() {
                gl_FragColor = vec4(uColor, 1.0);
            }
        `;

        // 정점 쉐이더 - 쉐도우맵 생성용
        const shadowVertexShader = `
            attribute vec3 aPosition;
            uniform mat4 uModelMatrix;                     
            uniform mat4 uLightMVP;
            
            void main() {
                vec4 worldPos = uModelMatrix * vec4(aPosition, 1.0);
                gl_Position = uLightMVP * worldPos;
            }
        `;

        // 프래그먼트 쉐이더 - 쉐도우맵 생성용                
        const shadowFragmentShader = `
            precision highp float;
            void main() {      
                gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);          
            }
        `;

        // 정점 쉐이더 - 렌더링용
        const renderVertexShader = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            
            uniform mat4 uModelMatrix;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uLightMVP;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec4 vShadowCoord;
            varying vec2 vTexCoord;
            
            const mat4 tMap = mat4(
                0.5, 0.0, 0.0, 0.0,
                0.0, 0.5, 0.0, 0.0,
                0.0, 0.0, 0.5, 0.0,
                0.5, 0.5, 0.5, 1.0
            );

            void main() {
                vec4 worldPos = uModelMatrix * vec4(aPosition, 1.0);
                gl_Position = uProjectionMatrix * uModelViewMatrix * worldPos;
                
                vNormal = mat3(uModelMatrix) * aNormal;
                vPosition = worldPos.xyz;
                vShadowCoord = uLightMVP * worldPos;
                vTexCoord = aTexCoord;
            }
        `;

        const renderFragmentShader = `
            precision highp float;
            
            uniform sampler2D uShadowMap;
            uniform sampler2D uTexture;
            uniform vec3 uLightPos;
            uniform float uLightSize;
            uniform int uSamples;
            uniform vec3 uModelColor;
            uniform bool uHasTexture;
            
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec4 vShadowCoord;
            varying vec2 vTexCoord;
            
            /*
            검은색 사각형 나오는 문제는 shadowCoord.x < 0 작은 경우 나오는 문제
            clamp to edge 이기 때문에, -0.3 도 0.0 으로 인식해서 잘못된 위치에 필터링 함.
            0.0, 1.0 벗어난 경우 뷰 프러스텀 영역 벗어났기 때문에 그림자가 없는 것으로 처리하자.
            */

            float hardShadow(vec3 shadowCoord, vec3 normal, vec3 lightDir) {
                // 2. 쉐도우맵에서 깊이 가져오기
                float shadowDepth = 0.0;

                if (shadowCoord.x < 0.0 || shadowCoord.x > 1.0 ||
                    shadowCoord.y < 0.0 || shadowCoord.y > 1.0 ||
                    shadowCoord.z < 0.0 || shadowCoord.z > 1.0) {                    
                    return 1.0;  // 그림자 없음
                } else {
                    shadowDepth = texture2D(uShadowMap, shadowCoord.xy).r;
                }
                
                float currentDepth = shadowCoord.z;
                // 4. 하드 쉐도우 계산 (bias 추가)
                
                // 왜 바이어스가 0.005 보다 작으면 이상한 사각형이 렌더링되지?                
                float bias = 0.005;
                // 각도에 따른 bias (표면이 빛과 평행할수록 큼)
                //float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    
                float shadow = (currentDepth - bias) > shadowDepth ? 0.0 : 1.0;                
                return shadow;
            }

            // Poisson disk를 함수로 반환
            vec2 getPoissonDisk(int index) {
                // 32 samples
                if (index == 0) return vec2(-0.94, -0.40);
                if (index == 1) return vec2(0.95, -0.77);
                if (index == 2) return vec2(-0.09, -0.93);
                if (index == 3) return vec2(0.34, 0.29);
                if (index == 4) return vec2(-0.92, 0.46);
                if (index == 5) return vec2(-0.82, -0.88);
                if (index == 6) return vec2(-0.38, 0.28);
                if (index == 7) return vec2(0.97, 0.76);
                if (index == 8) return vec2(0.44, -0.98);
                if (index == 9) return vec2(0.54, -0.47);
                if (index == 10) return vec2(-0.26, -0.42);
                if (index == 11) return vec2(0.79, 0.19);
                if (index == 12) return vec2(-0.24, 1.0);
                if (index == 13) return vec2(-0.81, 0.91);
                if (index == 14) return vec2(0.20, 0.79);
                if (index == 15) return vec2(0.14, -0.14);
                if (index == 16) return vec2(-0.53, -0.65);
                if (index == 17) return vec2(0.61, 0.35);
                if (index == 18) return vec2(-0.11, 0.48);
                if (index == 19) return vec2(0.88, -0.23);
                if (index == 20) return vec2(-0.67, 0.13);
                if (index == 21) return vec2(0.29, -0.79);
                if (index == 22) return vec2(-0.39, 0.87);
                if (index == 23) return vec2(0.72, 0.55);
                if (index == 24) return vec2(-0.15, -0.68);
                if (index == 25) return vec2(0.41, 0.63);
                if (index == 26) return vec2(-0.84, -0.29);
                if (index == 27) return vec2(0.33, -0.34);
                if (index == 28) return vec2(-0.58, 0.52);
                if (index == 29) return vec2(0.69, -0.61);
                if (index == 30) return vec2(-0.03, 0.22);
                if (index == 31) return vec2(0.51, 0.89);
                return vec2(0.0);
            }


            float PCF_Optimized(vec3 shadowCoord, vec3 normal, vec3 lightDir, float filterRadius) {
                // Early exit
                if (shadowCoord.x < 0.0 || shadowCoord.x > 1.0 ||
                    shadowCoord.y < 0.0 || shadowCoord.y > 1.0 ||
                    shadowCoord.z < 0.0 || shadowCoord.z > 1.0) {
                    return 1.0;
                }
                
                // Slope-dependent bias            
                float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
                bias = 0.005;
                float currentDepth = shadowCoord.z - bias;
                
                float shadow = 0.0;
                vec2 texelSize = 1.0 / vec2(512.0);
                
                // Poisson disk sampling (16 samples)
                for(int i = 0; i < 16; i++) {
                    vec2 offset = getPoissonDisk(i) * texelSize * filterRadius;
                    float shadowDepth = texture2D(uShadowMap, shadowCoord.xy + offset).r;
                    shadow += currentDepth > shadowDepth ? 0.0 : 1.0;
                }
                
                return shadow / 16.0;
            }

            void main() {
                // 쉐도우 좌표 변환
                vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;                
                shadowCoord = shadowCoord * 0.5 + 0.5;
                
                // 라이팅 계산
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPos - vPosition);
                float diff = max(dot(normal, lightDir), 0.0);
 
                float shadow = hardShadow(shadowCoord, normal, lightDir);                
                //float shadow = PCF_Optimized(shadowCoord, normal, lightDir, 1.5);

                // 최종 색상
                // dlgmlals3
                vec3 ambient = vec3(0.3);
                vec3 diffuse = vec3(1.0) * diff;
                vec3 lighting = ambient + diffuse * shadow;
                
                vec3 baseColor = uModelColor;
                if (uHasTexture) {
                    baseColor = texture2D(uTexture, vTexCoord).rgb;
                }
                                
                vec3 color = baseColor * lighting;
                //color = vec3(shadow); // dlgmlals3

                // 디버그: 우측 상단에 쉐도우맵 오버레이
                /*
                float uDebugShadow = 1.0;
                if (uDebugShadow == 1.0) {
                    vec2 screenPos = gl_FragCoord.xy / vec2(800.0, 600.0);
                    
                    // 우측 상단 영역 (0.7~1.0, 0.0 ~ 0.3)
                    if (screenPos.x > 0.7 && screenPos.y < 0.3) {
                        // 0.7~1.0 범위를 0~1로 정규화
                        vec2 debugUV = (screenPos - vec2(0.7, 0.0)) / 0.3;
                        float depth = texture2D(uShadowMap, debugUV).r;
                        color = vec3(depth);  // 원래 색상 대신 깊이로 덮어쓰기
                    }
                }
                */

                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // WebGL 초기화
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2를 지원하지 않는 브라우저입니다.');
            throw new Error('WebGL2 not supported');
        }
        
        console.log('✓ WebGL2 context created');

        // 쉐이더 컴파일 함수
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('쉐이더 컴파일 에러:', gl.getShaderInfoLog(shader));
                console.error('쉐이더 소스:', source);
                gl.deleteShader(shader);
                return null;
            }
            console.log('Shader compiled successfully:', type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT');
            return shader;
        }

        // 프로그램 생성 함수
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('프로그램 링크 에러:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            console.log('Program linked successfully');
            return program;
        }

        // 쉐이더 프로그램 생성
        const shadowVertShader = createShader(gl, gl.VERTEX_SHADER, shadowVertexShader);
        const shadowFragShader = createShader(gl, gl.FRAGMENT_SHADER, shadowFragmentShader);
        const shadowProgram = createProgram(gl, shadowVertShader, shadowFragShader);

        const renderVertShader = createShader(gl, gl.VERTEX_SHADER, renderVertexShader);
        const renderFragShader = createShader(gl, gl.FRAGMENT_SHADER, renderFragmentShader);
        const renderProgram = createProgram(gl, renderVertShader, renderFragShader);

        const frustumVertShader = createShader(gl, gl.VERTEX_SHADER, frustumVertexShader);
        const frustumFragShader = createShader(gl, gl.FRAGMENT_SHADER, frustumFragmentShader);
        const frustumProgram = createProgram(gl, frustumVertShader, frustumFragShader);

        // 매트릭스 유틸리티
        const mat4 = {
            create: () => new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]),
            
            perspective: (fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ]);
            },
            
            lookAt: (eye, center, up) => {
                const z = [
                    eye[0] - center[0],
                    eye[1] - center[1],
                    eye[2] - center[2]
                ];
                let len = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
                z[0] /= len; z[1] /= len; z[2] /= len;
                
                const x = [
                    up[1] * z[2] - up[2] * z[1],
                    up[2] * z[0] - up[0] * z[2],
                    up[0] * z[1] - up[1] * z[0]
                ];
                len = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
                x[0] /= len; x[1] /= len; x[2] /= len;
                
                const y = [
                    z[1] * x[2] - z[2] * x[1],
                    z[2] * x[0] - z[0] * x[2],
                    z[0] * x[1] - z[1] * x[0]
                ];
                
                return new Float32Array([
                    x[0], y[0], z[0], 0,
                    x[1], y[1], z[1], 0,
                    x[2], y[2], z[2], 0,
                    -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]),
                    -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]),
                    -(z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2]),
                    1
                ]);
            },
            
            multiply: (a, b) => {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] = 
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            },
            
            translate: (tx, ty, tz) => {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    tx, ty, tz, 1
                ]);
            },
            
            scale: (sx, sy, sz) => {
                return new Float32Array([
                    sx, 0, 0, 0,
                    0, sy, 0, 0,
                    0, 0, sz, 0,
                    0, 0, 0, 1
                ]);
            },
            
            rotateX: (angle) => {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ]);
            },
            
            rotateY: (angle) => {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ]);
            },
            
            rotateZ: (angle) => {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },

            inverse: (m) => {
                const inv = new Float32Array(16);
                
                inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
                        m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
                inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] -
                        m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
                inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
                        m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
                inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] -
                        m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
                
                inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] -
                        m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
                inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
                        m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
                inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
                        m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
                inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
                        m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
                
                inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
                        m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
                inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
                        m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
                inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
                        m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
                inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
                        m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
                
                inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
                        m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
                inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
                        m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
                inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
                        m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
                inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
                        m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];
                
                let det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
                
                if (det === 0) return m;
                
                det = 1.0 / det;
                
                const result = new Float32Array(16);
                for (let i = 0; i < 16; i++) {
                    result[i] = inv[i] * det;
                }
                return result;
            }

        };

        // 지오메트리 생성 (평면 + 큐브)
        function createGeometry() {
            // 바닥 평면 (더 크게)
            const planeVertices = new Float32Array([
                -10, 0, -10,  -10, 0, 10,  10, 0, 10,
                -10, 0, -10,  10, 0, 10,   10, 0, -10
            ]);
            const planeNormals = new Float32Array([
                0, 1, 0,  0, 1, 0,  0, 1, 0,
                0, 1, 0,  0, 1, 0,  0, 1, 0
            ]);
            
            // 큐브
            const cubeVertices = new Float32Array([
                // 앞면
                -0.5, 0, 0.5,  0.5, 0, 0.5,  0.5, 1, 0.5,
                -0.5, 0, 0.5,  0.5, 1, 0.5,  -0.5, 1, 0.5,
                // 뒷면
                0.5, 0, -0.5,  -0.5, 0, -0.5,  -0.5, 1, -0.5,
                0.5, 0, -0.5,  -0.5, 1, -0.5,  0.5, 1, -0.5,
                // 왼쪽면
                -0.5, 0, -0.5,  -0.5, 0, 0.5,  -0.5, 1, 0.5,
                -0.5, 0, -0.5,  -0.5, 1, 0.5,  -0.5, 1, -0.5,
                // 오른쪽면
                0.5, 0, 0.5,  0.5, 0, -0.5,  0.5, 1, -0.5,
                0.5, 0, 0.5,  0.5, 1, -0.5,  0.5, 1, 0.5,
                // 윗면
                -0.5, 1, 0.5,  0.5, 1, 0.5,  0.5, 1, -0.5,
                -0.5, 1, 0.5,  0.5, 1, -0.5,  -0.5, 1, -0.5
            ]);
            
            const cubeNormals = new Float32Array([
                0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,  0, 0, 1,
                0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,
                -1, 0, 0,  -1, 0, 0,  -1, 0, 0,  -1, 0, 0,  -1, 0, 0,  -1, 0, 0,
                1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,  1, 0, 0,
                0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0,  0, 1, 0
            ]);
            
            const frustumLines = new Float32Array([
                -1, -1, -1,  1, -1, -1,
                1, -1, -1,  1,  1, -1,
                1,  1, -1, -1,  1, -1,
                -1,  1, -1, -1, -1, -1,
                
                -1, -1,  1,  1, -1,  1,
                1, -1,  1,  1,  1,  1,
                1,  1,  1, -1,  1,  1,
                -1,  1,  1, -1, -1,  1,
                
                -1, -1, -1, -1, -1,  1,
                1, -1, -1,  1, -1,  1,
                1,  1, -1,  1,  1,  1,
                -1,  1, -1, -1,  1,  1
            ]);
            return {
                plane: { vertices: planeVertices, normals: planeNormals },
                cube: { vertices: cubeVertices, normals: cubeNormals },
                frustomLine : {vertices : frustumLines}
            };
        }

        const geometry = createGeometry();

        // 버퍼 생성
        const planeVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.plane.vertices, gl.STATIC_DRAW);

        const planeNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, planeNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.plane.normals, gl.STATIC_DRAW);

        const cubeVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.cube.vertices, gl.STATIC_DRAW);

        const cubeNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.cube.normals, gl.STATIC_DRAW);
        
        const frustumLineBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, frustumLineBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.frustomLine.vertices, gl.STATIC_DRAW);
        
        // 기본 UV 버퍼 (평면과 큐브용)
        const defaultUVs = new Float32Array([
            0, 0,  0, 1,  1, 1,
            0, 0,  1, 1,  1, 0
        ]);
        const defaultUVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, defaultUVBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, defaultUVs, gl.STATIC_DRAW);

        // GLTF 모델 데이터 저장
        let gltfModel = null;
        let gltfBuffers = [];
        let modelScale = 1.0;
        let modelOffset = [0, 0, 0];

        // GLTF 로더
        async function loadGLTF(file) {
            const reader = new FileReader();
            
            return new Promise((resolve, reject) => {
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        let gltfData;
                        let buffers = [];
                        
                        // GLB 파일 체크
                        const magic = new Uint32Array(arrayBuffer, 0, 1)[0];
                        console.log('File magic:', magic.toString(16));
                        
                        if (magic === 0x46546C67) { // "glTF" in little endian
                            console.log('Loading GLB format...');
                            // GLB 포맷
                            const view = new DataView(arrayBuffer);
                            const version = view.getUint32(4, true);
                            const length = view.getUint32(8, true);
                            
                            console.log('GLB version:', version, 'length:', length);
                            
                            let offset = 12;
                            let jsonChunk, binChunk;
                            
                            while (offset < length) {
                                const chunkLength = view.getUint32(offset, true);
                                const chunkType = view.getUint32(offset + 4, true);
                                
                                console.log('Chunk at', offset, 'length:', chunkLength, 'type:', chunkType.toString(16));
                                
                                if (chunkType === 0x4E4F534A) { // "JSON"
                                    const jsonData = new Uint8Array(arrayBuffer, offset + 8, chunkLength);
                                    const jsonString = new TextDecoder().decode(jsonData);
                                    gltfData = JSON.parse(jsonString);
                                    console.log('JSON chunk parsed:', gltfData);
                                } else if (chunkType === 0x004E4942) { // "BIN"
                                    binChunk = arrayBuffer.slice(offset + 8, offset + 8 + chunkLength);
                                    buffers.push(binChunk);
                                    console.log('Binary chunk loaded, size:', binChunk.byteLength);
                                }
                                
                                offset += 8 + chunkLength;
                            }
                        } else {
                            console.log('Loading GLTF format...');
                            // GLTF 포맷
                            const jsonString = new TextDecoder().decode(arrayBuffer);
                            gltfData = JSON.parse(jsonString);
                            console.log('GLTF parsed:', gltfData);
                            
                            // 외부 버퍼 로드 필요시 처리
                            if (gltfData.buffers) {
                                for (const buffer of gltfData.buffers) {
                                    if (buffer.uri) {
                                        alert('외부 버퍼가 있는 GLTF는 지원하지 않습니다. GLB 파일을 사용해주세요.');
                                        reject('External buffers not supported');
                                        return;
                                    }
                                }
                            }
                        }
                        
                        console.log('GLTF data loaded successfully');
                        resolve({ gltf: gltfData, buffers: buffers });
                    } catch (error) {
                        console.error('GLTF load error:', error);
                        reject(error);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // GLTF 데이터 파싱 및 버퍼 생성
        function parseGLTF(gltfData, buffers) {
            const meshes = [];
            
            // 바운딩 박스 계산용
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            
            console.log('Parsing GLTF, meshes:', gltfData.meshes.length);
            
            gltfData.meshes.forEach((mesh, meshIndex) => {
                console.log('Processing mesh', meshIndex, ':', mesh.name || 'unnamed');
                
                mesh.primitives.forEach((primitive, primIndex) => {
                    console.log('  Primitive', primIndex, 'attributes:', Object.keys(primitive.attributes));
                    
                    // Position 데이터
                    const positionAccessor = gltfData.accessors[primitive.attributes.POSITION];
                    const positionBufferView = gltfData.bufferViews[positionAccessor.bufferView];
                    const positionData = new Float32Array(
                        buffers[positionBufferView.buffer || 0],
                        (positionBufferView.byteOffset || 0) + (positionAccessor.byteOffset || 0),
                        positionAccessor.count * 3
                    );
                    console.log('  Position data count:', positionAccessor.count);
                    console.log('  First position:', positionData[0], positionData[1], positionData[2]);
                    
                    // UV 좌표 데이터
                    let uvData = null;
                    if (primitive.attributes.TEXCOORD_0 !== undefined) {
                        const uvAccessor = gltfData.accessors[primitive.attributes.TEXCOORD_0];
                        const uvBufferView = gltfData.bufferViews[uvAccessor.bufferView];
                        uvData = new Float32Array(
                            buffers[uvBufferView.buffer || 0],
                            (uvBufferView.byteOffset || 0) + (uvAccessor.byteOffset || 0),
                            uvAccessor.count * 2
                        );
                        console.log('  UV data loaded, count:', uvAccessor.count);
                    } else {
                        // UV가 없으면 기본값 생성
                        uvData = new Float32Array(positionAccessor.count * 2);
                        for (let i = 0; i < uvData.length; i += 2) {
                            uvData[i] = 0;
                            uvData[i + 1] = 0;
                        }
                    }
                    
                    // 바운딩 박스 업데이트
                    for (let i = 0; i < positionData.length; i += 3) {
                        minX = Math.min(minX, positionData[i]);
                        minY = Math.min(minY, positionData[i + 1]);
                        minZ = Math.min(minZ, positionData[i + 2]);
                        maxX = Math.max(maxX, positionData[i]);
                        maxY = Math.max(maxY, positionData[i + 1]);
                        maxZ = Math.max(maxZ, positionData[i + 2]);
                    }
                    
                    // Normal 데이터
                    let normalData;
                    if (primitive.attributes.NORMAL !== undefined) {
                        const normalAccessor = gltfData.accessors[primitive.attributes.NORMAL];
                        const normalBufferView = gltfData.bufferViews[normalAccessor.bufferView];
                        normalData = new Float32Array(
                            buffers[normalBufferView.buffer || 0],
                            (normalBufferView.byteOffset || 0) + (normalAccessor.byteOffset || 0),
                            normalAccessor.count * 3
                        );
                    } else {
                        // 노멀이 없으면 기본값 생성
                        console.log('  No normals, generating default');
                        normalData = new Float32Array(positionAccessor.count * 3);
                        for (let i = 0; i < normalData.length; i += 3) {
                            normalData[i] = 0;
                            normalData[i + 1] = 1;
                            normalData[i + 2] = 0;
                        }
                    }
                    
                    // Index 데이터 (있는 경우)
                    let indexData = null;
                    let indexCount = positionAccessor.count;
                    let indexType = gl.UNSIGNED_SHORT;
                    
                    if (primitive.indices !== undefined) {
                        const indexAccessor = gltfData.accessors[primitive.indices];
                        const indexBufferView = gltfData.bufferViews[indexAccessor.bufferView];
                        
                        if (indexAccessor.componentType === 5123) { // UNSIGNED_SHORT
                            indexData = new Uint16Array(
                                buffers[indexBufferView.buffer || 0],
                                (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0),
                                indexAccessor.count
                            );
                            indexType = gl.UNSIGNED_SHORT;
                        } else if (indexAccessor.componentType === 5125) { // UNSIGNED_INT
                            indexData = new Uint32Array(
                                buffers[indexBufferView.buffer || 0],
                                (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0),
                                indexAccessor.count
                            );
                            indexType = gl.UNSIGNED_INT;
                        } else if (indexAccessor.componentType === 5121) { // UNSIGNED_BYTE
                            indexData = new Uint8Array(
                                buffers[indexBufferView.buffer || 0],
                                (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0),
                                indexAccessor.count
                            );
                            indexType = gl.UNSIGNED_BYTE;
                        }
                        indexCount = indexAccessor.count;
                        console.log('  Index count:', indexCount, 'type:', indexType);
                    }
                    
                    // WebGL 버퍼 생성
                    const vertexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);
                    
                    const normalBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
                    
                    const uvBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, uvData, gl.STATIC_DRAW);
                    
                    let indexBuffer = null;
                    if (indexData) {
                        indexBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
                    }
                    
                    // 색상 정보 (머티리얼에서)
                    let color = [0.8, 0.8, 0.8]; // 기본 회색
                    let texture = null;
                    let hasTexture = false;
                    
                    if (primitive.material !== undefined && gltfData.materials) {
                        const material = gltfData.materials[primitive.material];
                        if (material.pbrMetallicRoughness) {
                            if (material.pbrMetallicRoughness.baseColorFactor) {
                                color = material.pbrMetallicRoughness.baseColorFactor.slice(0, 3);
                            }
                            
                            // 텍스처 로드
                            if (material.pbrMetallicRoughness.baseColorTexture) {
                                const textureIndex = material.pbrMetallicRoughness.baseColorTexture.index;
                                const textureInfo = gltfData.textures[textureIndex];
                                const imageIndex = textureInfo.source;
                                const image = gltfData.images[imageIndex];
                                
                                console.log('  Loading texture from image', imageIndex);
                                console.log('  Image info:', image);
                                
                                // 이미지 데이터 로드
                                if (image.bufferView !== undefined) {
                                    const bufferView = gltfData.bufferViews[image.bufferView];
                                    const imageData = new Uint8Array(
                                        buffers[bufferView.buffer || 0],
                                        bufferView.byteOffset || 0,
                                        bufferView.byteLength
                                    );
                                    
                                    console.log('  Image buffer size:', imageData.byteLength);
                                    
                                    // MIME 타입 감지 (매직 넘버로)
                                    let mimeType = image.mimeType;
                                    if (!mimeType) {
                                        // PNG: 89 50 4E 47
                                        if (imageData[0] === 0x89 && imageData[1] === 0x50 && imageData[2] === 0x4E && imageData[3] === 0x47) {
                                            mimeType = 'image/png';
                                        }
                                        // JPEG: FF D8 FF
                                        else if (imageData[0] === 0xFF && imageData[1] === 0xD8 && imageData[2] === 0xFF) {
                                            mimeType = 'image/jpeg';
                                        }
                                        // WebP: 52 49 46 46 ... 57 45 42 50
                                        else if (imageData[0] === 0x52 && imageData[1] === 0x49 && imageData[2] === 0x46 && imageData[3] === 0x46) {
                                            mimeType = 'image/webp';
                                        }
                                        else {
                                            mimeType = 'image/png'; // 기본값
                                        }
                                        console.log('  Detected MIME type:', mimeType);
                                    }
                                    
                                    texture = gl.createTexture();
                                    
                                    // 임시 1x1 픽셀 텍스처로 초기화 (로딩 전까지 사용)
                                    gl.bindTexture(gl.TEXTURE_2D, texture);
                                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, 
                                        new Uint8Array([200, 200, 200, 255]));
                                    
                                    // Base64로 변환 (큰 이미지도 안정적)
                                    let binary = '';
                                    const len = imageData.byteLength;
                                    for (let i = 0; i < len; i++) {
                                        binary += String.fromCharCode(imageData[i]);
                                    }
                                    const base64 = btoa(binary);
                                    const dataUrl = `data:${mimeType};base64,${base64}`;
                                    
                                    console.log('  Creating image from base64 data...');
                                    
                                    const img = new Image();
                                    
                                    img.onload = function() {
                                        console.log('  ✓ Image loaded successfully! Dimensions:', img.width, 'x', img.height);
                                        gl.bindTexture(gl.TEXTURE_2D, texture);
                                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                                        
                                        // 파워 오브 투 체크
                                        const isPowerOf2 = (value) => (value & (value - 1)) === 0;
                                        if (isPowerOf2(img.width) && isPowerOf2(img.height)) {
                                            gl.generateMipmap(gl.TEXTURE_2D);
                                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                                        } else {
                                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                                        }
                                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                                        
                                        console.log('  ✓ Texture setup complete!');
                                    };
                                    
                                    img.onerror = function(e) {
                                        console.error('  ✗ Image load error:', e);
                                        console.error('  MIME type was:', mimeType);
                                        console.error('  First bytes:', Array.from(imageData.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                                        console.error('  Data URL length:', dataUrl.length);
                                    };
                                    
                                    img.src = dataUrl;
                                    hasTexture = true;
                                    console.log('  Texture object created, loading image...');
                                }
                            }
                        }
                    }
                    
                    meshes.push({
                        vertexBuffer,
                        normalBuffer,
                        uvBuffer,
                        indexBuffer,
                        indexCount,
                        indexType,
                        hasIndices: indexData !== null,
                        color: color,
                        texture: texture,
                        hasTexture: hasTexture
                    });
                    
                    console.log('  Mesh added with color:', color, 'hasTexture:', hasTexture);
                });
            });
            
            // 바운딩 박스 정보
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            console.log('Bounding box:');
            console.log('  Min:', minX, minY, minZ);
            console.log('  Max:', maxX, maxY, maxZ);
            console.log('  Center:', centerX, centerY, centerZ);
            console.log('  Size:', sizeX, sizeY, sizeZ);
            console.log('  Max dimension:', maxSize);
            
            // 모델을 2 유닛 크기로 정규화
            modelScale = maxSize > 0 ? 2.0 / maxSize : 1.0;
            modelOffset = [-centerX, -minY, -centerZ]; // 바닥이 Y=0에 오도록
            
            console.log('Model scale:', modelScale);
            console.log('Model offset:', modelOffset);
            console.log('Total meshes parsed:', meshes.length);
            
            return meshes;
        }

        // GLTF 파일 입력 처리
        document.getElementById('gltfFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                document.getElementById('modelStatus').textContent = '로딩 중...';
                document.getElementById('modelStatus').style.color = '#ffeb3b';
                const { gltf, buffers } = await loadGLTF(file);
                gltfModel = parseGLTF(gltf, buffers);
                gltfBuffers = buffers;
                
                document.getElementById('modelStatus').textContent = `로드 완료! (${gltfModel.length} meshes)`;
                document.getElementById('modelStatus').style.color = '#4CAF50';
                
                console.log('=== GLTF Model Loaded ===');
                console.log('Total meshes:', gltfModel.length);
                gltfModel.forEach((mesh, i) => {
                    console.log(`Mesh ${i}: color =`, mesh.color, 'vertices =', mesh.indexCount);
                });
            } catch (error) {
                console.error('GLTF 로드 에러:', error);
                document.getElementById('modelStatus').textContent = '로드 실패';
                document.getElementById('modelStatus').style.color = '#f44336';
            }
        });

        // 쉐도우맵 프레임버퍼 생성 - WebGL2 네이티브 깊이 텍스처
        // dlgmlals3
        const shadowMapSize = 512;
        const shadowFramebuffer = gl.createFramebuffer();
        const shadowTexture = gl.createTexture();
        
        // WebGL2는 깊이 텍스처를 네이티브로 지원 (확장 불필요)
        gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT32F, shadowMapSize, shadowMapSize, 0, gl.DEPTH_COMPONENT, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFramebuffer);
        
        
        gl.drawBuffers([gl.NONE]); // 컬러버퍼에 안씀         
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, shadowTexture, 0);

        // 프레임버퍼 완성도 체크
        const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
            console.error('Framebuffer is not complete:', fbStatus);
        } else {
            console.log('✓ Shadow framebuffer ready (WebGL2 depth texture)');
        }
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // 설정값
        let lightSize = 0.01;
        let samples = 32;
        let lightHeight = 3;
        let lightRotation = 45;
        let debugShadow = false;
        let modelX = 0;
        let modelY = 0;
        let modelZ = 0;
        let modelRotX = 0;
        let modelRotY = 0;
        let modelRotZ = 0;

        // 카메라 컨트롤
        let cameraDistance = 8;
        let cameraRotationX = 0.4; // 위아래 각도 (라디안)
        let cameraRotationY = 0; // 좌우 각도 (라디안)
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // UI 컨트롤
        document.getElementById('lightSize').addEventListener('input', (e) => {
            lightSize = parseFloat(e.target.value);
            document.getElementById('lightSizeValue').textContent = lightSize.toFixed(3);
        });
        
        document.getElementById('samples').addEventListener('input', (e) => {
            samples = parseInt(e.target.value);
            document.getElementById('samplesValue').textContent = samples;
        });
        
        document.getElementById('lightHeight').addEventListener('input', (e) => {
            lightHeight = parseFloat(e.target.value);
            document.getElementById('lightHeightValue').textContent = lightHeight.toFixed(1);
        });
        
        document.getElementById('lightRotation').addEventListener('input', (e) => {
            lightRotation = parseFloat(e.target.value);
            document.getElementById('lightRotationValue').textContent = lightRotation.toFixed(0) + '°';
        });
        
        
        document.getElementById('modelY').addEventListener('input', (e) => {
            modelY = parseFloat(e.target.value);
            document.getElementById('modelYValue').textContent = modelY.toFixed(3);
        });
        
        document.getElementById('debugShadow').addEventListener('change', (e) => {
            debugShadow = e.target.checked;
        });

        // 마우스 카메라 컨트롤
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;

            cameraRotationY += deltaX * 0.01;
            cameraRotationX += deltaY * 0.01;

            // 위아래 각도 제한 (거의 수직 방지)
            cameraRotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotationX));

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // 마우스 휠 - 줌 인/아웃
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(2, Math.min(30, cameraDistance));
        }, { passive: false });

        
        // 섀도우 렌더 부터 그려보자.
        // 새도우 맵(텍스처)는 0 ~ 1로 정규화됨
        // 0 이면 near Plane, 1 이면 far plane
        function shadowRender() {
            // shadow map 직접 렌더링
            if (debuggingRendering) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS); // 기본 깊이 함수
                gl.depthMask(true); // 깊이 쓰기 활성화    
            } else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFramebuffer);                     
                gl.enable(gl.DEPTH_TEST);
                gl.clearDepth(1.0);           
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.DEPTH_BUFFER_BIT);                
                gl.depthFunc(gl.LESS); // 기본 깊이 함수
                gl.depthMask(true); // 깊이 쓰기 활성화
            }

            gl.useProgram(shadowProgram);                   
            const renderPosLoc = gl.getAttribLocation(shadowProgram, 'aPosition');
            const modelLoc = gl.getUniformLocation(shadowProgram, 'uModelMatrix');                        
            const lightMVPLoc = gl.getUniformLocation(shadowProgram, 'uLightMVP');

            const angle = lightRotation * Math.PI / 180;                        
            const lightPos = [
                Math.cos(angle) * 5,
                lightHeight,
                Math.sin(angle) * 5
            ];
            // dlgmlals3
            const lightTarget = [0, 0, 0];            
            // texture map width height 동일해서 aspect 1.0으로 행주어야 함.
            const lightProjection = mat4.perspective(Math.PI / 4, 1.0, 0.1, 50);
            const lightView = mat4.lookAt(lightPos, lightTarget, [0, 1, 0]);                                    
            //const lightMVP = mat4.multiply(lightProjection, lightView);
            const lightMVP = mat4.multiply(lightView, lightProjection);                                 
            gl.uniformMatrix4fv(lightMVPLoc, false, lightMVP);            
            
            // 평면 그리기
            const identityMatrix = mat4.create();
            gl.uniformMatrix4fv(modelLoc, false, identityMatrix);            
            gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexBuffer);
            gl.enableVertexAttribArray(renderPosLoc);
            gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            

            // 큐브 그리기
            gl.uniformMatrix4fv(modelLoc, false, identityMatrix);            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
            gl.enableVertexAttribArray(renderPosLoc);
            gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 30);
            
            
            // GLTF 모델 그리기            
            if (gltfModel) {
                const translateMatrix = mat4.translate(
                    modelOffset[0] + modelX, 
                    modelOffset[1] + modelY, 
                    modelOffset[2] + modelZ
                );
                const scaleMatrix = mat4.scale(modelScale, modelScale, modelScale);
                
                const rotX = mat4.rotateX(modelRotX * Math.PI / 180);
                const rotY = mat4.rotateY(modelRotY * Math.PI / 180);
                const rotZ = mat4.rotateZ(modelRotZ * Math.PI / 180);
                
                let modelMatrix = scaleMatrix;
                modelMatrix = mat4.multiply(rotZ, modelMatrix);
                modelMatrix = mat4.multiply(rotY, modelMatrix);
                modelMatrix = mat4.multiply(rotX, modelMatrix);
                modelMatrix = mat4.multiply(translateMatrix, modelMatrix);
                
                gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
                
                gltfModel.forEach(mesh => {
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                    gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);
                    
                    if (mesh.hasIndices) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
                        gl.drawElements(gl.TRIANGLES, mesh.indexCount, mesh.indexType, 0);
                    } else {
                        gl.drawArrays(gl.TRIANGLES, 0, mesh.indexCount);
                    }
                });
            } 
            
            if (debuggingRendering) {
                requestAnimationFrame(shadowRender);
            }         
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);   
        }

        function renderFrustomLine(lightView, lightProjection, view, projection) {
            // Frustum 그리기
            gl.useProgram(frustumProgram);
            
            const frustumPosLoc = gl.getAttribLocation(frustumProgram, 'aPosition');
            const frustumMVPLoc = gl.getUniformLocation(frustumProgram, 'uMVP');
            const frustumColorLoc = gl.getUniformLocation(frustumProgram, 'uColor');
            
            // 정확한 변환 순서:
            // 1. lightProjection의 역행렬로 NDC -> 라이트 뷰 공간
            // 2. lightView의 역행렬로 라이트 뷰 공간 -> 월드 공간
            // 3. view로 월드 공간 -> 카메라 뷰 공간
            // 4. projection으로 카메라 뷰 공간 -> NDC
            
            const lightProjInv = mat4.inverse(lightProjection);
            const lightViewInv = mat4.inverse(lightView);
            
            // 월드 공간으로 변환
            const frustumWorld = mat4.multiply(lightViewInv, lightProjInv);
            
            // 카메라 공간으로 변환
            const frustumMVP = mat4.multiply(projection, mat4.multiply(view, frustumWorld));
            
            gl.uniformMatrix4fv(frustumMVPLoc, false, frustumMVP);
            gl.uniform3f(frustumColorLoc, 1.0, 1.0, 0.0);

            gl.bindBuffer(gl.ARRAY_BUFFER, frustumLineBuffer);
            gl.enableVertexAttribArray(frustumPosLoc);
            gl.vertexAttribPointer(frustumPosLoc, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.LINES, 0, 24);            
        }
        // 렌더링 함수
        function render() {
            shadowRender();
            //console.log("dlgmlals3 render");

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LESS); // 기본 깊이 함수
            gl.depthMask(true); // 깊이 쓰기 활성화

            // 2. 일반 렌더링
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            const angle = lightRotation * Math.PI / 180;                        
            const lightPos = [
                Math.cos(angle) * 5,
                lightHeight,
                Math.sin(angle) * 5
            ];
            const lightTarget = [0, 0, 0];
            const lightProjection = mat4.perspective(Math.PI / 4, 1.0, 0.1, 50);
            const lightView = mat4.lookAt(lightPos, lightTarget, [0, 1, 0]);
            const lightMVP = mat4.multiply(lightView, lightProjection);
            //const lightMVP = mat4.multiply(lightProjection, lightView);
            
            // 카메라 위치 계산            
            const projection = mat4.perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 50);         
            const camX = cameraDistance * Math.cos(cameraRotationX) * Math.sin(cameraRotationY);
            const camY = cameraDistance * Math.sin(cameraRotationX);
            const camZ = cameraDistance * Math.cos(cameraRotationX) * Math.cos(cameraRotationY);   
            const view = mat4.lookAt([camX, camY, camZ], [0, 0, 0], [0, 1, 0]);            
            const modelView = view;

            gl.useProgram(renderProgram);
            // coordinate
            const renderPosLoc = gl.getAttribLocation(renderProgram, 'aPosition'); // plane + gltf position
            const renderNormalLoc = gl.getAttribLocation(renderProgram, 'aNormal'); // plane + gltf normal
            const renderTexCoordLoc = gl.getAttribLocation(renderProgram, 'aTexCoord'); // plane + gltf uv

            // matrix
            const projLoc = gl.getUniformLocation(renderProgram, 'uProjectionMatrix'); // proj
            const mvLoc = gl.getUniformLocation(renderProgram, 'uModelViewMatrix'); // view matrix
            const modelLoc = gl.getUniformLocation(renderProgram, 'uModelMatrix'); // world matrix

            const lightMVPLoc = gl.getUniformLocation(renderProgram, 'uLightMVP');
            const lightPosLoc = gl.getUniformLocation(renderProgram, 'uLightPos');
            const lightSizeLoc = gl.getUniformLocation(renderProgram, 'uLightSize');            
            const samplesLoc = gl.getUniformLocation(renderProgram, 'uSamples');
            const shadowMapLoc = gl.getUniformLocation(renderProgram, 'uShadowMap');
            const textureLoc = gl.getUniformLocation(renderProgram, 'uTexture');
            const modelColorLoc = gl.getUniformLocation(renderProgram, 'uModelColor');
            const hasTextureLoc = gl.getUniformLocation(renderProgram, 'uHasTexture');
            
            gl.uniformMatrix4fv(projLoc, false, projection);
            gl.uniformMatrix4fv(mvLoc, false, modelView);
            gl.uniformMatrix4fv(lightMVPLoc, false, lightMVP);
            gl.uniform3fv(lightPosLoc, lightPos);
            gl.uniform1f(lightSizeLoc, lightSize);
            gl.uniform1i(samplesLoc, samples);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
            gl.uniform1i(shadowMapLoc, 0);
            
            const identityMatrix = mat4.create();
            
            // 평면 그리기
            gl.uniformMatrix4fv(modelLoc, false, identityMatrix);
            gl.uniform3f(modelColorLoc, 0.5, 0.5, 0.5);
            gl.uniform1i(hasTextureLoc, 0);            
            gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexBuffer);
            gl.enableVertexAttribArray(renderPosLoc);
            gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);            
            
            gl.bindBuffer(gl.ARRAY_BUFFER, planeNormalBuffer);
            gl.enableVertexAttribArray(renderNormalLoc);
            gl.vertexAttribPointer(renderNormalLoc, 3, gl.FLOAT, false, 0, 0);            
            
            gl.bindBuffer(gl.ARRAY_BUFFER, defaultUVBuffer);            
            gl.enableVertexAttribArray(renderTexCoordLoc);
            gl.vertexAttribPointer(renderTexCoordLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            // 큐브 그리기
            gl.uniformMatrix4fv(modelLoc, false, identityMatrix);            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
            gl.enableVertexAttribArray(renderPosLoc);
            gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, cubeNormalBuffer);
            gl.enableVertexAttribArray(renderNormalLoc);
            gl.vertexAttribPointer(renderNormalLoc, 3, gl.FLOAT, false, 0, 0);            
            
            gl.drawArrays(gl.TRIANGLES, 0, 30);

            // GLTF 모델 그리기
            if (gltfModel) {
                const translateMatrix = mat4.translate(
                    modelOffset[0] + modelX, 
                    modelOffset[1] + modelY, 
                    modelOffset[2] + modelZ
                );
                const scaleMatrix = mat4.scale(modelScale, modelScale, modelScale);
                
                const rotX = mat4.rotateX(modelRotX * Math.PI / 180);
                const rotY = mat4.rotateY(modelRotY * Math.PI / 180);
                const rotZ = mat4.rotateZ(modelRotZ * Math.PI / 180);
                
                let modelMatrix = scaleMatrix;
                modelMatrix = mat4.multiply(rotZ, modelMatrix);
                modelMatrix = mat4.multiply(rotY, modelMatrix);
                modelMatrix = mat4.multiply(rotX, modelMatrix);
                modelMatrix = mat4.multiply(translateMatrix, modelMatrix);
                
                gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
                
                gltfModel.forEach(mesh => {
                    gl.uniform3fv(modelColorLoc, mesh.color);
                    gl.uniform1i(hasTextureLoc, mesh.hasTexture ? 1 : 0);
                    
                    if (mesh.hasTexture && mesh.texture) {
                        gl.activeTexture(gl.TEXTURE1);
                        gl.bindTexture(gl.TEXTURE_2D, mesh.texture);
                        gl.uniform1i(textureLoc, 1);
                    }
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                    gl.vertexAttribPointer(renderPosLoc, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                    gl.vertexAttribPointer(renderNormalLoc, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.uvBuffer);
                    gl.vertexAttribPointer(renderTexCoordLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    if (mesh.hasIndices) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);
                        gl.drawElements(gl.TRIANGLES, mesh.indexCount, mesh.indexType, 0);
                    } else {
                        gl.drawArrays(gl.TRIANGLES, 0, mesh.indexCount);
                    }
                });
            }                
            renderFrustomLine(lightView, lightProjection, modelView, projection);

            // render is driven from shadowRender loop so it does not request another frame
            requestAnimationFrame(render);
        }
        if (debuggingRendering) {
            shadowRender();
        } else {
            render();
        }                 
    </script>
</body>
</html>
