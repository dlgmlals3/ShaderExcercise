<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKSL 셰이더 교육 자료</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <h1> SKSL 셰이더 교육 자료</h1>
        <p> Chapter 4. Fractal 만들어보기 </p>

        <nav class="chapter-nav">
            <a href="index.html" class="chapter-btn"> 0. 기본 함수 설명 </a>
            <a href="chapter1.html" class="chapter-btn">1. 기본 도형과 패턴
            <a href="chapter2.html" class="chapter-btn">2. 기본 도형 회전 이동 확대
            <a href="chapter3.html" class="chapter-btn">3. 랜덤 함수와 노이즈 함수 </a><br>
            <a href="chapter4.html" class="chapter-btn active">4. Fractal </a>
            <a href="chapter5.html" class="chapter-btn">5. 이미지 필터링 및 컬러 커브 </a>
            <a href="chapter6.html" class="chapter-btn">6. 블러 알고리즘 </a>
            <a href="chapter7.html" class="chapter-btn">7. 멀티 패스 </a>
        </nav>
    </div>

    <div class="container">
        <div class="lesson">
            <div class="lesson-header">
                <div class="lesson-title"> Fractal, Octave, Fbm, Domain Warping 이해하기 </div>
                <div class="lesson-description">
                    <h3> 학습 목표</h3>
                    <br>Fractal 란 ? 자기 유사성을 가진 패턴을 의미한다<br>
                    확대 해도 비슷한 패턴이 반복되는 특징이 있다.<br>
                    눈송이, 나무, 고사리 등 자연계에서 자주 발생이 된다 <br>
                    Ex) 나무로 예를 들면, 큰 나무 가지가 뻗어있는 모양을 확대 하면, 작은 나무 가지들이 뻗어있고 <br>
                    다시 확대하면 더 작은 나무 가지가 뻗어있는 모양이 반복된다.<br><br>
                    
                    Octave 기법은 프랙탈 구조인 패턴을 합성하여 복잡한 패턴을 생성 <br>
                    큰 스케일 (멀리서 octave 1) + 중간 스케일(중간 거리, octave 2) + 작은 스케일(가까이서, octave 3) <br>
                    각 패턴들은 비슷한 디테일이 계속 나타나고 (fractal) 
                    여러 옥타브의 패턴을 합성하여 복잡한 패턴을 생성하는 기법이 Octave 기법 이다.<br><br>


                    복잡한 패턴을 생성하기 위해 자주 사용하는 것이 fBM (Fractal Brownian Motion)기법 이다<br>
                    fBM은 Octave 기법을 사용하여 노이즈를 생성하는 기법이다.<br><br>
                    
                    fractal 패턴을 생성하기 위해서는 진폭과 주파수의 대해서 알아야 한다.<br>
                    진폭과 주파수 개념을 이해한다.<br><br>
                    <img src="materials/chapter4/amplitudeFreq.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                    <video width="640" height="360" controls>
                    <source src="materials/chapter4/amfm.mp4" type="video/mp4">
                    </video>
                </div>
            </div>

            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts1')">
                    <h4> 그래프 그려보기  ( 라이브러리 포함 ) </h4><br>                    
                    <span class="toggle-icon" id="icon-concepts1">▼</span>
                </div>
                <div class="concepts-content" id="concepts1">
                    <ul>                       
                        <li><strong> AM, FM 파동 려보기 </strong><br>
                            <div class="code-example">                     
<code>p.y *= 5;
p.x *= 10.;
float amplitude = 1.;
float frequency = 1.;
float y = amplitude * sin(p.x * frequency);</code>
                            </div>
                        </li>          
                    </ul>
                    <li><strong> 파동 중첩 상쇄 시켜보기 (NoiseCanceling) </strong><br>
                    <div class="code-example">                     
<code>p.y *= 3;
p.x *= 10.;
float amplitude = 1.;
float frequency = 1.;
float t = 0.01*(-iTime * 130.0);

float y = sin(p.x * frequency);
y += sin(p.x * frequency * 2.1 + t) * 4.5; // 파동 1
y += sin(p.x * frequency*1.72 + t*1.121) * 4.0; // 파동 2
y += sin(p.x * frequency*2.221 + t*0.437) * 5.0; // 파동 3
y += sin(p.x * frequency*3.120+ t*4.269) * 2.5; // 파동 4

//y -= sin(p.x * frequency * 2.1 + t) * 4.5; // 파동 1 상쇄
//y -= sin(p.x * frequency*1.72 + t*1.121) * 4.0; // 파동 2 상쇄
//y -= sin(p.x * frequency*2.221 + t*0.437) * 5.0; // 파동 3 상쇄
//y -= sin(p.x * frequency*3.120+ t*4.269) * 2.5; // 파동 4 상쇄
//y -= sin(p.x * frequency);
y *= amplitude * 0.06;</code>
                            </div>
                    </li>
                    <li><strong> 파동 중첩 증폭 시켜보기 </strong><br>
                    <div class="code-example">                     
<code>p.y *= 3;
p.x *= 10.;
float amplitude = 1.;
float frequency = 1.;
float t = 0.01*(-iTime * 130.0);

// 각 주파수에 증폭 계수 설정
float bass_boost = 2.0;      // 저음 증폭
float mid_boost = 0.5;       // 중음 감소
float treble_boost = 3.0;    // 고음 증폭

float y = sin(p.x * frequency) * bass_boost;
y += sin(p.x * frequency * 2.1 + t) * 4.5 * mid_boost;
y += sin(p.x * frequency*1.72 + t*1.121) * 4.0 * mid_boost;
y += sin(p.x * frequency*2.221 + t*0.437) * 5.0 * treble_boost;
y += sin(p.x * frequency*3.120+ t*4.269) * 2.5 * treble_boost;

y *= amplitude * 0.06;</code>
                    </div>
                    </li>                    
                </div>
            </div>

            <div class="lesson-content">
                <div class="editor-section">
                    <div class="section-header">SKSL 실습 코드</div>
                    <textarea class="code-editor" id="editor1">
float y = p.x;           
                    </textarea>
                    <div class="controls">
                        <button class="btn" onclick="compileShader(1)"> 실행</button>                     
                    </div>
                </div>
                
                <div class="preview-section">
                    <div class="section-header">미리보기</div>
                    <div id="error1"></div>
                    <div class="preview-container">
                        <div class="loading" id="loading1">CanvasKit 로딩 중...</div>
                        <canvas class="preview-canvas" id="canvas1" width="300" height="300" style="display: none;"></canvas>
                    </div>
                </div>
            </div>


            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts2')">
                    <h4> Fractal Brownian Motion  </h4><br>                                        
                    <span class="toggle-icon" id="icon-concepts2">▼</span>
                </div>
                <div class="concepts-content" id="concepts2">
                    <br><h3>Fractal Brownian Motion (fBm) </h3><br>
                    여러 옥타브의 노이즈를 합성하여 복잡한 패턴을 생성하는 기법입니다. <br>
                    각 옥타브는 주파수와 진폭이 다르며, 이를 통해 자연스러운 텍스처와 패턴을 만들어낼 수 있습니다.<br><br>
                    <ul>                                                   
                        <li><strong> fBM </strong><br>
                            <div class="code-example">                     
<code>uniform vec2 iResolution;
uniform float iTime;
float random (in vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*  43758.5453123);
}

float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

float fbm (in vec2 st) {
    // Initial values
    float value = 0.0;
    float amplitude = .5;
    float frequency = 0.;
    //
    // Loop of octaves
    for (int i = 0; i < 6; i++) {
        value += amplitude * noise(st);
        st *= 2.;
        amplitude *= .5;
    }
    return value;
}

half4 main(float2 fragCoord) {
    vec2 st = fragCoord.xy/iResolution.xy;
    st.x *= iResolution.x/iResolution.y;	
    vec3 color = vec3(0.);

    color += fbm(st * 3.0);
    return vec4(color, 1.0);
}
</code>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts3')">
                    <h4> Domain Warping  </h4><br>                                        
                    <span class="toggle-icon" id="icon-concepts3">▼</span>
                </div>
                <div class="concepts-content" id="concepts3">
                    <br><h3> Domain Warping (좌표 왜곡) </h3><br>
                    노이즈로 좌표 자체를 뒤틀어서, 그 뒤틀린 좌표로 다시 노이즈를 샘플링하는 기법입니다.
                    일반 노이즈보다 훨씬 더 복잡하고 유기적인 패턴을 만들 수 있음.<br><br>

                    fbm 함수는 좌표를 전달 받고, 그 좌표에 대해 여러 옥타브의 노이즈를 합성하여 복잡한 패턴 생성을 해준다.<br><br>

                    1차 fbm 함수를 통해 얻은 노이즈 값을<br>
                    다시 현 좌표와 시간값을 조합하여 2차 fbm 함수를 호출하여 노이즈값 생성한다.<br>
                    오리지널 좌표에 노이즈 값을 반영하게 되면, 기존 좌표가 왜곡이 되어 좌표계가 왜곡이 된다.<br>
                    이러한 왜곡된 좌표를 가지고 Fbm 함수를 실행하여 노이즈 값을 출력하면,<br>
                    마치 구겨진 종이 위(왜곡된 좌표계)에 잉크를 떨어뜨리고 다시 폈을대 보이는 현상으로 이해하면 좋다.<br><br><br>
                    <img src="materials/chapter4/warping.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br><br>
                    <ul>                                                   
                        <li><strong> Domain Warping (Noise 생성) </strong><br>
                            <div class="code-example">                     
<code>uniform vec2 iResolution;
uniform float iTime;

float random(in vec2 _st) {
    return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float noise(in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);
    
    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    
    vec2 u = f * f * (3.0 - 2.0 * f);
    
    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float fbm(in vec2 _st) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5),
                    -sin(0.5), cos(0.5));
    
    for (int i = 0; i < 5; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

float fbm2 (in vec2 st) {
    // Initial values
    float value = 0.0;
    float amplitude = .5;
    float frequency = 0.;
    //
    // Loop of octaves
    for (int i = 0; i < 6; i++) {
        value += amplitude * noise(st);
        st *= 2.;
        amplitude *= .5;
    }
    return value;
}

vec4 main(vec2 fragCoord) {
    vec2 st = fragCoord / iResolution.xy * 3.0;
    
    vec3 color = vec3(0.0);
    
    // Domain warping - 첫 번째 왜곡 (q : 왜곡한 양)
    vec2 q = vec2(0.0);
    q.x = fbm2(st);
    q.y = fbm2(st + vec2(1.0));
    
    //q.x = fbm2(st + vec2(-0.5, 0.0) * iTime);

    // Domain warping - 두 번째 왜곡
    vec2 r = vec2(0.0);
    r.x = fbm2(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * iTime);
    r.y = fbm2(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * iTime);
    
    // Domain warping - 세 번째 왜곡
    float f = fbm2(st + r);    
    f = 0;
    //f = q.x;
    //f = r.y;

    // 컬러링    
    color = mix(vec3(0.101961, 0.619608, 0.666667), // 청록색
                vec3(0.666667, 0.666667, 0.498039), // 회갈색
                clamp((f * f) * 4.0, 0.0, 1.0));
    
    /*
    color = mix(color,
                vec3(0.0, 0.0, 0.164706), // 어두운 파랑(깊이감)
                clamp(length(q), 0.0, 1.0));
    
    color = mix(color,
                vec3(0.666667, 1.0, 1.0), // 밝은 하늘색
                clamp(length(r.x), 0.0, 1.0));
    */
    return vec4((f * f * f + 0.6 * f * f + 0.5 * f) * color, 1.0);
}</code>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts4')">
                    <h4> 물결 모양 만들어보기  </h4><br>                                        
                    <span class="toggle-icon" id="icon-concepts4">▼</span>
                </div>
                <div class="concepts-content" id="concepts4">
                    <br><h3> 물결 모양 만들기 </h3><br>
                    <video width="640" height="360" controls>
                    <source src="materials/chapter4/ripple.mp4" type="video/mp4">
                    </video>
                    <ul>                                                   
                        <br><li><strong> sin,cos 사용하여 반복패턴 만들기 </strong><br>
                            <img src="materials/chapter4/distance.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
half4 main(float2 fragCoord) {    
    vec2 uv = fragCoord/iResolution.xy;
    
    vec2 center = vec2(.5, .5);
    float dist = distance(uv, center);

    float pattern = sin(dist * 6.);    
    vec3 color = vec3(1., 0., 0.);    
    color *= pattern;
    return vec4(color, 1.);
}
</code>
                            </div>
                        </li>
                    </ul>
                    <ul>                                                   
                        <li><strong> 물결 모양 2 </strong><br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
uniform float iTime;
half4 main(float2 fragCoord) {    
    vec2 uv = fragCoord / iResolution;
    vec2 center = vec2(0.5, 0.5);
    float dist = distance(uv, center);
    
    // 시간에 따라 바깥으로 퍼지는 물결
    float ripple = sin(dist * 20.0 - iTime * 3.0);
    
    return vec4(vec3(ripple), 1.0);
}
</code>
                            </div>
                        </li>
                    </ul>
                    <ul>                                                   
                        <li><strong> 물결 모양 3 (감쇠 반응 추가) </strong><br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
uniform float iTime;
half4 main(float2 fragCoord) {    
    vec2 uv = fragCoord / iResolution;
    vec2 center = vec2(0.5, 0.5);
    float dist = distance(uv, center);       
    float ripple = sin(dist * 20.0 - iTime * 3.0);
    float fade = 1.0 / (1.0 + dist * 5.0);  // 감쇠 계수
    //float fade = 1.0 / (pow((dist + 1.), 8.));  // 감쇠 계수

    // 거리가 멀어질수록 약해지는 물결
    ripple *= fade;  // 감쇠 적용
    
    vec3 waterColor = vec3(0.2, 0.6, 1.0);
    vec3 color = waterColor * ripple;
    
    return vec4(color, 1.0);
}
</code>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            
            <div class="key-concepts">
                <div class="concepts-header" onclick="toggleConcepts('concepts5')">
                    <h4> 메타볼 만들기  </h4><br>                                       
                    <span class="toggle-icon" id="icon-concepts5">▼</span>
                </div>
                <div class="concepts-content" id="concepts5">
                    <br><h3> 메타볼 만들기  </h3><br>
                    <video width="640" height="360" controls>
                    <source src="materials/chapter4/metaball.mp4" type="video/mp4">
                    </video>
                    <ul>                                                   
                        <li><strong> 메타볼 만들어보기  1</strong><br>
                            3개의 원을 주기적으로 랜덤하게 움직여보자<br>
                            2 가지를 반드시 이해하자 <br>
                            1) 특정 주기로 애니메이션 하는 트릭을 알아본다.<br>                            
                            2) Idx가 원의 인덱스를 이해하고, 해시 파라메터에 idx 포함된 연산이 추가되면 원마다 다른 해쉬값을 얻어 오는 것을 이해<br><br>
                            <img src="materials/chapter4/period.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
uniform float iTime;

// 해시/랜덤 유틸
float hash11(float x) {
    return fract(sin(x * 1.12345) * 43758.5453123);
}

vec2 hash21(float x) {
    float a = hash11(x);
    float b = hash11(x + 37.23);
    return vec2(a, b);
}

vec2 randPos(float k, float idx) {
    vec2 h = hash21(k * 13.0 + idx * 97.0) * 2.0 - 1.0;
    return h * vec2(0.42, 0.32);
}

float randRad(float k, float idx) {
    // 0.2 ~ 0.3 보간
    return mix(0.20, 0.30, hash11(k * 19.0 + idx * 131.0));
}

// 구간별 랜덤 모핑
void getRandomMorph(out vec2 P[3], out float R[3], float t) {
    float period = 2.7; // 한 구간의 길이
    float seg = floor(t / period); // 몇번째 구간
    float ft = (t / period) - seg; // 구간 진행도. 3.27 - 3 = 0.27 = 27%
    float w = smoothstep(0.0, 1.0, ft); // 2.7초 주기에 해당하는 보간된 값.

    // idx는 원의 인덱스
    for (int i = 0; i < 3; i++) {
        float idx = float(i);
        vec2 A = randPos(seg + idx * 0.37, idx);
        vec2 B = randPos((seg + 1.0) + idx * 0.37, idx);
        float RA = randRad(seg + idx * 0.51, idx);
        float RB = randRad((seg + 1.0) + idx * 0.51, idx);
        
        vec2 p = mix(A, B, w);
        float r = mix(RA, RB, w);
        
        P[i] = p;
        R[i] = r;
    }
}

float drawCircle(float2 pos, float2 center, float radius) {
    float dist = distance(pos, center);    
    return step(dist, radius);
}

half4 main(float2 fragCoord) {
    vec2 uv = (fragCoord / iResolution);
    uv.y = 1.- uv.y;
    uv -= .5;

    // 랜덤 모핑으로 centers와 radii 생성
    vec2 centers[3];
    float radii[3];
    getRandomMorph(centers, radii, iTime);

    // 파라미터 설정
    float threshold = 1.35;
    float edge = 1.5 / iResolution.y;
    vec3 fillColor = vec3(0.18, 0.78, 1.00);
    vec3 bgColor = vec3(0.0);

    // 메타볼 그리기 (파라미터화된 함수 사용)
    vec3 color = vec3(0.0);
    color += drawCircle(uv, centers[0], radii[0]);
    color += drawCircle(uv, centers[1], radii[1]);
    color += drawCircle(uv, centers[2], radii[2]);
    return vec4(color, 1.0);
}</code>
                            </div>
                        </li>
                    </ul>
                    <ul>                                                   
                        <li><strong> 메타볼 만들어보기 2 </strong><br>
                            장력 구하기 (표면장력, 자기장,. ..)<br>
                            <img src="materials/chapter4/field.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                            <img src="materials/chapter4/field2.png" alt="circle" style="max-width: 100%; height: auto; margin-bottom: 10px;"><br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
uniform float iTime;

float metaballField(vec2 point, vec2 centers[3], float radii[3]) {
    float sum = 0.0;
    float eps = 1e-4;

    for (int i = 0; i < 3; i++) {
        float d = length(point - centers[i]);
        sum += (radii[i] * radii[i]) / (d * d + eps);
    }

    return sum;
}

half4 main(float2 fragCoord) {
    vec2 uv = (fragCoord / iResolution);
    uv.y = 1.- uv.y;
    uv -= .5;

    // 랜덤 모핑으로 centers와 radii 생성
    vec2 centers[3];
    centers[0] = vec2(0., 0.); centers[1] = vec2(0.2, 0.2); centers[2] = vec2(0.5, 0.5);
    float radii[3];
    radii[0] = 0.2; radii[1] = 0.15; radii[2] = 0.1;

    vec3 fillColor = vec3(0.18, 0.78, 1.00);
    vec3 bgColor = vec3(0.0);

    // 메타볼 그리기 (파라미터화된 함수 사용)
    vec3 color = fillColor;
    float field = metaballField(uv, centers, radii);
    
    float edge1 = 2.85;
    float smooth = 0.1;
    field = smoothstep(edge1 - smooth, edge1 + smooth, field);
    
    color = vec3(field);
    return vec4(color, 1.0);
}</code>
                            </div>
                        </li>
                    </ul>

                    <ul>                                                   
                        <li><strong> 메타볼 만들어보기 3 </strong><br>
                            모두 합친 메타볼 코드 <br>
                            <div class="code-example">                     
<code>uniform float2 iResolution;
uniform float iTime;

// 해시/랜덤 유틸
float hash11(float x) {
    return fract(sin(x * 1.12345) * 43758.5453123);
}

vec2 hash21(float x) {
    float a = hash11(x);
    float b = hash11(x + 37.23);
    return vec2(a, b);
}

vec2 randPos(float k, float idx) {
    vec2 h = hash21(k * 13.0 + idx * 97.0) * 2.0 - 1.0;
    return h * vec2(0.32, 0.32);
}

float randRad(float k, float idx) {
    // 0.2 ~ 0.3 보간
    return mix(0.10, 0.15, hash11(k * 19.0 + idx * 131.0));
}

// 구간별 랜덤 모핑
void getRandomMorph(out vec2 P[3], out float R[3], float t) {
    float period = 2.7; // 한 구간의 길이
    float seg = floor(t / period); // 몇번째 구간
    float ft = (t / period) - seg; // 구간 진행도. 3.27 - 3 = 0.27 = 27%
    float w = smoothstep(0.0, 1.0, ft); // 2.7초 주기에 해당하는 보간된 값.

    // idx는 원의 인덱스
    for (int i = 0; i < 3; i++) {
        float idx = float(i);
        vec2 A = randPos(seg + idx, idx);
        vec2 B = randPos((seg + 1.0) + idx, idx);
        float RA = randRad(seg + idx * 0.51, idx);
        float RB = randRad((seg + 1.0) + idx * 0.51, idx);
        
        vec2 p = mix(A, B, w);
        float r = mix(RA, RB, w);
                
        float s1 = sin(t * 1.7 + idx * 2.1);
        float s2 = sin(t * 3.9 + idx * 1.3);
        // 미세한 떨림을 추가.
        p += 0.02 * vec2(s1, s2);
        // 미세하게 반지름 크기 변화
        r *= (1.0 + 0.03 * sin(t * 2.3 + idx));
        p.y -= 0.05;
        
        P[i] = p;
        R[i] = r;
    }
}

// 메타볼 필드 계산 (파라미터: point, centers[], radii[])
float metaballField(vec2 point, vec2 centers[3], float radii[3]) {
    float sum = 0.0;
    float eps = 1e-4;

    for (int i = 0; i < 3; i++) {
        float d = length(point - centers[i]);
        sum += (radii[i] * radii[i]) / (d * d + eps);
    }

    return sum;
}

// 필드를(0~무한대) 마스크(0~1)로 변환
float metaballMask(float threshold, float edge, float x) {
    return smoothstep(threshold - edge, threshold + edge, x);
}

vec3 drawMetaballs(vec2 point, vec2 centers[3], float radii[3], 
                float threshold, float edge, vec3 fillColor, vec3 bgColor) {
    float field = metaballField(point, centers, radii);
    float mask = metaballMask(threshold, edge, field);
    return mix(bgColor, fillColor, mask);
}

half4 main(float2 fragCoord) {
    vec2 uv = (fragCoord / iResolution);
    uv.y = 1.- uv.y;
    uv -= .5;
    float t = iTime;
    // 랜덤 모핑으로 centers와 radii 생성
    vec2 centers[3];
    float radii[3];
    getRandomMorph(centers, radii, t);

    // 파라미터 설정
    float threshold = 1.35;
    float edge = 1.5 / iResolution.y;
    vec3 fillColor = vec3(0.18, 0.78, 1.00);
    vec3 bgColor = vec3(0.0);

    vec3 color = vec3(0.0);
    color = drawMetaballs(uv, centers, radii, threshold, edge, fillColor, bgColor);
    return vec4(color, 1.0);
}
</code>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="lesson-content">
                <div class="editor-section">
                    <div class="section-header">SKSL 코드</div>
                    <textarea class="code-editor" id="editor2">
uniform float2 iResolution;
half4 main(float2 fragCoord) {    
    return vec4(0.0, 1.0, 0.0, 1.0);
}
</textarea>
                    <div class="controls">
                        <button class="btn" onclick="compileShader(2)">실행</button>
                    </div>
                </div>

                <div class="preview-section">
                    <div class="section-header">미리보기</div>
                    <div id="error2"></div>
                    <div class="preview-container">
                        <div class="loading" id="loading2">CanvasKit 로딩 중...</div>
                        <canvas class="preview-canvas" id="canvas2" width="300" height="300" style="display: none;"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleConcepts(conceptsId) {
            const content = document.getElementById(conceptsId);
            const icon = document.getElementById(`icon-${conceptsId}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                icon.textContent = '▲';
                icon.style.transform = 'rotate(180deg)';
            } else {
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                icon.textContent = '▼';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function toggleCode(codeId) {
            const content = document.getElementById(codeId);
            const toggle = document.getElementById(`toggle-${codeId}`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.style.maxHeight = '400px';
                toggle.textContent = '접기';
            } else {
                content.classList.add('collapsed');
                content.style.maxHeight = '0';
                toggle.textContent = '펼치기';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // concepts2, concepts3만 닫고 싶다면:
            const sectionsToClose = ['concepts1', 'concepts2', 'concepts3', 'concepts4', 'concepts5', 'concepts6', 'concepts7',
                'concepts8'
            ];
            
            sectionsToClose.forEach(conceptsId => {
                const content = document.getElementById(conceptsId);
                const icon = document.getElementById(`icon-${conceptsId}`);
                const header = document.querySelector(`[onclick="toggleConcepts('${conceptsId}')"]`);
                
                if (content) {
                    content.classList.add('collapsed');
                    content.style.maxHeight = '0';
                }
                if (icon) {
                    icon.textContent = '▼';
                }
                if (header) {
                    header.classList.add('closed');
                }
            });
        });

        // Placeholder functions for shader compilation
        function compileShader(id) {
            console.log(`Compiling shader ${id}...`);
            // 실제 셰이더 컴파일 로직이 여기에 들어갑니다
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvaskit-wasm/0.38.0/canvaskit.min.js"></script>
    <script src="shader-tutorial.js"></script>
</body>
</html>